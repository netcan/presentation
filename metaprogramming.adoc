= C++æ¨¡æ¿å…ƒç¼–ç¨‹
:customcss: presentation.css
:revealjsdir: https://cdn.jsdelivr.net/npm/reveal.js@3.9.2
:revealjs_theme: serif
:highlightjs-theme: https://cdn.jsdelivr.net/npm/highlight.js@10.2.1/styles/atom-one-light.css
:highlightjs-languages: cpp
:source-highlighter: highlightjs
:revealjs_history: true
:icons: font
:stem:
ç½—èƒ½ {docdate} @Shanghai

[subtitle]#template <typename ğŸ˜€>#

== æ¨¡æ¿ä»‹ç»

[%step]
* èµ·åˆä¸ºäº†æ”¯æŒæ³›å‹æ›¿ä»£å®è€Œè®¾è®¡çš„è¯­æ³•
* ç±»å‹å®‰å…¨ï¼Œç¼–è¯‘æœŸæå‰æ£€æŸ¥é”™è¯¯
* äººä»¬æ— æ„ä¸­å‘ç°å¯ä»¥ç”¨äº [red]*ç¼–è¯‘æœŸ* è®¡ç®—
* è¯­è¨€æ ‡å‡†å‘å±•ä¸æ–­å®Œå–„å…ƒç¼–ç¨‹ä½“éªŒ

== æ³›å‹ç®—æ³• & å®

[.fragment]
[source,cpp]
----
#define MAX(X, Y) (((X) > (Y)) ? (X) : (Y))
MAX(a++, b++) // (((a++) > (b++)) ? (a++) : (b++))
MAX(0, "123") // runtime error
----

[.fragment]
[source,cpp,subs="none"]
----
void qsort( void *ptr, size_t count, size_t size,
    int (*comp)(const <mark>void *</mark>, const <mark>void *</mark>) );
----

[.fragment]
[source,cpp]
----
int values[] = { 88, 56, 100, 2, 25 };
int cmpfunc (const void* a, const void* b) {
   return ( *(int*)a - *(int*)b );
}
qsort(values, 5, sizeof(int), cmpfunc);
----

=== æ³›å‹ç®—æ³• & æ¨¡æ¿å‡½æ•°
[.fragment]
[source,cpp]
----
template<typename T>
T max(T&& a, T&& b) {
    return a > b ? a : b;
}
----

[.fragment]
[source,cpp]
----
max(0, "123"); // error: no matching function for call to 'max(int, const char [4])'
----

[.fragment]
[source,cpp]
----
template<class RandomIt, class Compare>
void sort(RandomIt first, RandomIt last, Compare comp);
----

[.fragment]
[source,cpp]
----
int values[] = { 88, 56, 100, 2, 25 };
std::sort(values, values + 5, [](int a, int b) {
    return a < b;
});
----

=== æ³›å‹å®¹å™¨ & å®
[source,cpp]
----
// collection.h
struct Collection_ ## TYPE {
 TYPE *array; // <1>
 size_t size, n;
};

#ifdef INSTANCE // <2>
Collection_ ## TYPE make_Collection_ ## TYPE(size_t sz) {
    // ...
}
#endif
----
[.fragment]
<1> ç±»å‹å‚æ•° `TYPE`
<2> å®ä¾‹åŒ–å‡½æ•°

=== æ³›å‹å®¹å™¨ & å®
[source,cpp]
----
// main.cpp
#define INSTANCE

#define TYPE int // <1>
#include "collection.h"
#undef TYPE

#define TYPE string // <1>
#include "collection.h"
#undef TYPE

int main() {
    Collection_int lstInt = make_Collection_int(5); // <2>
    Collection_double lstDouble = make_Collection_double(5);
}
----
[.fragment]
<1> å®ä¾‹åŒ–ç±»å‹ `Collection<int>`, `Collection<string>`
<2> å®ä¾‹åŒ–æˆå‘˜å‡½æ•°

=== æ³›å‹å®¹å™¨ & æ¨¡æ¿
[source,cpp]
----
// collection.h
template <typename T> // <1>
class Collection {
    T* array;
    size_t size, n;
public:
    Collection(size_t sz) {
        // ...
    }
};

// main.cpp
int main() {
    Collection<int> lstInt(5); // <2>
    Collection<double> lstDouble(5); // <2>
}
----
[.fragment]
<1> æ¨¡æ¿å‚æ•° `T`
<2> å®ä¾‹åŒ–ç±»å‹ `Collection<int>`, `Collection<double>`

== é›¶æˆæœ¬æŠ½è±¡
[quote, Bjarne Stroustrup, 'http://www.stroustrup.com/ETAPS-corrected-draft.pdf[Foundations of C++]']
____
C++ implementations obey the zero-overhead principle:
What you donâ€™t use, you donâ€™t pay for. And further: What you do use, you couldnâ€™t hand code any better.
____

[.notes]
--
C++ç‰¹æ€§å¼•è¿›åŸåˆ™ï¼Œå¾—éµå®ˆä¸ä¼šå¸¦æ¥é¢å¤–å¼€é”€ï¼Œä¸è®ºæ—¶é—´ä¸Šè¿˜æ˜¯ç©ºé—´ä¸Šï¼Œéƒ½æ¯”ç¨‹åºçŒ¿è‡ªå·±å®ç°ç±»ä¼¼çš„ç‰¹æ€§è¦å¥½ï¼ˆè‡³å°‘ä¸å·®ï¼‰

ç„¶è€ŒRTTIå’Œå¼‚å¸¸è¿èƒŒäº†è¿™ä¸ªåŸåˆ™ï¼Œæ‰€ä»¥ç¼–è¯‘å™¨éƒ½æœ‰å¼€å…³å…³æ‰è¿™ç‰¹æ€§ã€‚
--

== å…ƒç¼–ç¨‹ & Metaprogramming

[%step]
* ç¼–è¯‘å™¨è§£ææ‰§è¡Œä»£ç ï¼Œå¹¶ *ç”Ÿæˆ* ä»£ç ã€æ•°æ®
* å°†è¿è¡Œæ—¶é€»è¾‘æŒªåˆ°ç¼–è¯‘æ—¶è®¡ç®—ï¼Œå®ç°é›¶æˆæœ¬æŠ½è±¡
* è¿è¡Œæ—¶æ‹¥æœ‰æ”¹å˜ç»“æ„çš„èƒ½åŠ›ï¼ŒåŠ¨é™ç»“åˆ

=== å…ƒç¼–ç¨‹ & æµæ´¾
[%step]
* https://www.youtube.com/watch?v=PJwd4JLYJJY[Constexpr all the things!]
* æ¨¡æ¿å…ƒç¼–ç¨‹
* ä¸¤è€…ç»“åˆ

=== Constexpr all the things!
image::constexpr-all-the-things.png[80%,80%]

[.notes]
--
constexprç›®å‰è¿˜ä¸æˆç†Ÿï¼Œè¦æ±‚å¤ªé«˜ï¼ŒC++20æ”¯æŒç¼–è¯‘æœŸåˆ†é…å†…å­˜åï¼Œå°±èƒ½å¢åŠ ä½¿ç”¨é¢äº†ï¼Œé™ä½é—¨æ§›ã€‚
--

[.columns]
=== æ¨¡æ¿å…ƒç¼–ç¨‹
[.column]
--
è¿è¡Œæ—¶äº¤äº’

[%step]
* æ•°å€¼
* å¯¹è±¡
--

[.column]
--
ç¼–è¯‘æ—¶è®¡ç®—

[%step]
* æ•°å€¼
* ç±»å‹
* å¯¹è±¡ (C++20)
--

=== æ¨¡æ¿å…ƒç¼–ç¨‹
å‡½æ•°å¼ç¼–ç¨‹èŒƒå¼

[%step]
* æ— å‰¯ä½œç”¨çº¯å‡½æ•°
* å»¶è¿Ÿè®¡ç®—
* æ¨¡å¼åŒ¹é…

[.columns]
=== æ¨¡æ¿å…ƒç¼–ç¨‹ï¼šæ•°å€¼è®¡ç®—
[.column]
--
è®¡ç®—Fibonacciæ•°åˆ—: stem:[f(n) = f(n-1) + f(n-2)]
[.fragment]
[source,cpp]
----
template <size_t N> // <1>
struct Fibonacci {  // <2>
    constexpr static size_t value = // <3>
        Fibonacci<N - 1>::value +
        Fibonacci<N - 2>::value;
};

template <> struct Fibonacci<0> {   // <4>
    constexpr static size_t value = 0;
};

template <> struct Fibonacci<1> {   // <4>
    constexpr static size_t value = 1;
}

template<size_t N>
constexpr size_t Fibonacci_v = Fibonacci<N>::value; // <5>
----
--

[.column.is-one-third]
--
[.fragment]
<1> æ¨¡æ¿å…ƒå‡½æ•° [.blue]*è¾“å…¥* å‚æ•°N
<2> æ¨¡æ¿å…ƒå‡½æ•°å `Fibonacci`
<3> æ¨¡æ¿å…ƒå‡½æ•° [.blue]*è¾“å‡º* è¿”å›å€¼ `value`
<4> æ¨¡å¼åŒ¹é…ï¼Œå‡½æ•°é€’å½’çš„è¾¹ç•Œæ¡ä»¶
<5> åˆ«åï¼Œæ–¹ä¾¿è°ƒç”¨

[.fragment]
icon:question[role="orange"]
å¦‚ä½•è°ƒç”¨

[.fragment]
[source,cpp]
----
Fibonacci<10>::value // 55
Fibonacci_v<10> // 55
----

[.fragment]
TIP: çº¦å®š [.blue]*å°–æ‹¬å·* ä¸ºæ¨¡æ¿å…ƒå‡½æ•°è°ƒç”¨ï¼Œ`value` ä½œä¸ºå‡½æ•°çš„ [.blue]*è¿”å›å€¼*
--

[.columns]
=== æ¨¡æ¿å…ƒç¼–ç¨‹ï¼šç±»å‹è®¡ç®—
[.column]
--
è®¡ç®—ç±»å‹ `T` çš„æŒ‡é’ˆç±»å‹ `T*`
[.fragment]
[source,cpp]
----
template <typename T> // <1>
struct AddPointer {   // <2>
    using type = T*;  // <3>
};

template <typename T>
using AddPointer_t =
    typename AddPointer<T>::type; // <4>
----
--

[.column]
--
[.fragment]
<1> æ¨¡æ¿å…ƒå‡½æ•° [.blue]*è¾“å…¥* ç±»å‹T
<2> æ¨¡æ¿å…ƒå‡½æ•°å
<3> æ¨¡æ¿å…ƒå‡½æ•° [.blue]*è¾“å‡º* è¿”å›ç±»å‹ `type`
<4> åˆ«åï¼Œæ–¹ä¾¿è°ƒç”¨

[.fragment]
icon:question[role="orange"]
å¦‚ä½•è°ƒç”¨

[.fragment]
[source,cpp]
----
AddPointer<int>::type px = new int{5};
AddPointer_t<int> px2 = new int{5};
----

[.fragment]
TIP: çº¦å®š [.blue]*å°–æ‹¬å·* ä¸ºæ¨¡æ¿å…ƒå‡½æ•°è°ƒç”¨ï¼Œ`type` ä½œä¸ºå‡½æ•°çš„ [.blue]*è¿”å›ç±»å‹*
--

=== æ¨¡æ¿å…ƒç¼–ç¨‹ï¼šåŸºç¡€æ•°æ®ç±»å‹



