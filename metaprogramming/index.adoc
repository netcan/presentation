= C++æ¨¡æ¿å…ƒç¼–ç¨‹
:customcss: ../presentation.css
:revealjsdir: ../node_modules/reveal.js
:revealjs_plugins: ../presentation_plugins.js
:revealjs_plugins_configuration: ../presentation_plugins_conf.js
:revealjs_theme: serif
:highlightjs-theme: https://cdn.jsdelivr.net/npm/highlight.js@10.2.1/styles/atom-one-light.css
:highlightjs-languages: cpp
:source-highlighter: highlightjs
:revealjs_history: true
:revealjs_pdfseparatefragments: false
:revealjs_transition: zoom
:revealjs_slideNumber: c/t
:revealjs_fragmentInURL: true
:icons: font
:stem:
ç½—èƒ½ {docdate} @Shanghai

[subtitle]#template <typename ğŸ˜€>#

== æ¨¡æ¿ä»‹ç»

[%step]
* èµ·åˆä¸ºäº†æ”¯æŒæ³›å‹æ›¿ä»£å®è€Œè®¾è®¡çš„è¯­æ³•
* ç±»å‹å®‰å…¨ï¼Œç¼–è¯‘æœŸæå‰æ£€æŸ¥é”™è¯¯
* äººä»¬æ— æ„ä¸­å‘ç°å¯ä»¥ç”¨äº [red]*ç¼–è¯‘æœŸ* è®¡ç®—
* è¯­è¨€æ ‡å‡†å‘å±•ä¸æ–­å®Œå–„å…ƒç¼–ç¨‹ä½“éªŒ

== æ³›å‹ç®—æ³• & å®

[.fragment]
[source,cpp]
----
#define MAX(X, Y) (((X) > (Y)) ? (X) : (Y))
MAX(a++, b++) // (((a++) > (b++)) ? (a++) : (b++))
MAX(0, "123") // runtime error
----

[.fragment]
[source,cpp,subs="none"]
----
void qsort( void *ptr, size_t count, size_t size,
    int (*comp)(const <mark>void *</mark>, const <mark>void *</mark>) );
----

[.fragment]
[source,cpp]
----
int values[] = { 88, 56, 100, 2, 25 };
int cmpfunc (const void* a, const void* b) {
   return ( *(int*)a - *(int*)b );
}
qsort(values, 5, sizeof(int), cmpfunc);
----

=== æ³›å‹ç®—æ³• & æ¨¡æ¿å‡½æ•°
[.fragment]
[source,cpp]
----
template<typename T>
T max(T&& a, T&& b) {
    return a > b ? a : b;
}
----

[.fragment]
[source,cpp]
----
max(0, "123"); // error: no matching function for call to 'max(int, const char [4])'
----

[.fragment]
[source,cpp]
----
template<class RandomIt, class Compare>
void sort(RandomIt first, RandomIt last, Compare comp);
----

[.fragment]
[source,cpp]
----
int values[] = { 88, 56, 100, 2, 25 };
std::sort(values, values + 5, [](int a, int b) {
    return a < b;
});
----

=== æ³›å‹å®¹å™¨ & å®
[source,cpp]
----
// collection.h
struct Collection_ ## TYPE {
 TYPE *array; // <1>
 size_t size, n;
};

#ifdef INSTANCE // <2>
Collection_ ## TYPE make_Collection_ ## TYPE(size_t sz) {
    // ...
}
#endif
----
[.fragment]
<1> ç±»å‹å‚æ•° `TYPE`
<2> å®ä¾‹åŒ–å‡½æ•°

=== æ³›å‹å®¹å™¨ & å®
[source,cpp]
----
// main.cpp
#define INSTANCE

#define TYPE int // <1>
#include "collection.h"
#undef TYPE

#define TYPE string // <1>
#include "collection.h"
#undef TYPE

int main() {
    Collection_int lstInt = make_Collection_int(5); // <2>
    Collection_double lstDouble = make_Collection_double(5);
}
----
[.fragment]
<1> å®ä¾‹åŒ–ç±»å‹ `Collection_int`, `Collection_string`
<2> å®ä¾‹åŒ–æˆå‘˜å‡½æ•°

=== æ³›å‹å®¹å™¨ & æ¨¡æ¿
[source,cpp]
----
// collection.h
template <typename T> // <1>
class Collection {
    T* array;
    size_t size, n;
public:
    Collection(size_t sz) {
        // ...
    }
};

// main.cpp
int main() {
    Collection<int> lstInt(5); // <2>
    Collection<double> lstDouble(5); // <2>
}
----
[.fragment]
<1> æ¨¡æ¿å‚æ•° `T`
<2> å®ä¾‹åŒ–ç±»å‹ `Collection<int>`, `Collection<double>`

== é›¶æˆæœ¬æŠ½è±¡
[quote, Bjarne Stroustrup, 'http://www.stroustrup.com/ETAPS-corrected-draft.pdf[Foundations of C++]']
____
C++ implementations obey the zero-overhead principle:
What you donâ€™t use, you donâ€™t pay for. And further: What you do use, you couldnâ€™t hand code any better.
____

[.notes]
--
C++ç‰¹æ€§å¼•è¿›åŸåˆ™ï¼Œå¾—éµå®ˆä¸ä¼šå¸¦æ¥é¢å¤–å¼€é”€ï¼Œä¸è®ºæ—¶é—´ä¸Šè¿˜æ˜¯ç©ºé—´ä¸Šï¼Œéƒ½æ¯”ç¨‹åºçŒ¿è‡ªå·±å®ç°ç±»ä¼¼çš„ç‰¹æ€§è¦å¥½ï¼ˆè‡³å°‘ä¸å·®ï¼‰

ç„¶è€ŒRTTIå’Œå¼‚å¸¸è¿èƒŒäº†è¿™ä¸ªåŸåˆ™ï¼Œæ‰€ä»¥ç¼–è¯‘å™¨éƒ½æœ‰å¼€å…³å…³æ‰è¿™ç‰¹æ€§ã€‚
--

== å…ƒç¼–ç¨‹ & Metaprogramming

[%step]
* ç¼–è¯‘å™¨è§£ææ‰§è¡Œä»£ç ï¼Œå¹¶ *ç”Ÿæˆ* ä»£ç ã€æ•°æ®
* å°†è¿è¡Œæ—¶é€»è¾‘æŒªåˆ°ç¼–è¯‘æ—¶è®¡ç®—ï¼Œå®ç°é›¶æˆæœ¬æŠ½è±¡
* è¿è¡Œæ—¶æ‹¥æœ‰æ”¹å˜ç»“æ„çš„èƒ½åŠ›ï¼ŒåŠ¨é™ç»“åˆ

=== å…ƒç¼–ç¨‹ & æµæ´¾
[%step]
* https://www.youtube.com/watch?v=PJwd4JLYJJY[Constexpr all the things!]
* æ¨¡æ¿å…ƒç¼–ç¨‹
* ä¸¤è€…ç»“åˆ

=== Constexpr all the things!
image::constexpr-all-the-things.png[80%,80%]

[.notes]
--
constexprç›®å‰è¿˜ä¸æˆç†Ÿï¼Œè¦æ±‚å¤ªé«˜ï¼ŒC++20æ”¯æŒç¼–è¯‘æœŸåˆ†é…å†…å­˜åï¼Œå°±èƒ½å¢åŠ ä½¿ç”¨é¢äº†ï¼Œé™ä½é—¨æ§›ã€‚
--

[.columns]
=== æ¨¡æ¿å…ƒç¼–ç¨‹
[.column]
--
è¿è¡Œæ—¶äº¤äº’

[%step]
* æ•°å€¼
* å¯¹è±¡
--

[.column]
--
ç¼–è¯‘æ—¶è®¡ç®—

[%step]
* æ•°å€¼
* ç±»å‹
* å¯¹è±¡ (C++20)
--

=== æ¨¡æ¿å…ƒç¼–ç¨‹
å‡½æ•°å¼ç¼–ç¨‹èŒƒå¼

[%step]
* æ— å‰¯ä½œç”¨çº¯å‡½æ•°
* å»¶è¿Ÿè®¡ç®—
* æ¨¡å¼åŒ¹é…

[.notes]
--
ç”±æœ€åŸºæœ¬çš„å‡½æ•°ï¼Œé€šè¿‡å‡½æ•°ç»„åˆå®ç°å¤æ‚é€»è¾‘
--

[.columns]
=== æ¨¡æ¿å…ƒç¼–ç¨‹ï¼šæ•°å€¼è®¡ç®—
[.column]
--
è®¡ç®—Fibonacciæ•°åˆ—: stem:[f(n) = f(n-1) + f(n-2)]
[.fragment]
[source,cpp]
----
template <size_t N> // <1>
struct Fibonacci {  // <2>
    constexpr static size_t value = // <3>
        Fibonacci<N - 1>::value +
        Fibonacci<N - 2>::value;
};

template <> struct Fibonacci<0> {   // <4>
    constexpr static size_t value = 0;
};

template <> struct Fibonacci<1> {   // <4>
    constexpr static size_t value = 1;
}

template<size_t N>
constexpr size_t Fibonacci_v = Fibonacci<N>::value; // <5>
----
--

[.column.is-one-third]
--
[.fragment]
<1> æ¨¡æ¿å…ƒå‡½æ•° [.blue]*è¾“å…¥* å‚æ•°Nï¼Œ`size_t` è¡¨æ˜è¾“å…¥å‚æ•°ä¸º [.blue]*å€¼*
<2> æ¨¡æ¿å…ƒå‡½æ•°å `Fibonacci`
<3> æ¨¡æ¿å…ƒå‡½æ•° [.blue]*è¾“å‡º* è¿”å› [.blue]*å€¼* `value`
<4> æ¨¡å¼åŒ¹é…ï¼Œå‡½æ•°é€’å½’çš„è¾¹ç•Œæ¡ä»¶
<5> åˆ«åï¼Œæ–¹ä¾¿è°ƒç”¨

[.fragment]
icon:question[role="orange"]
å¦‚ä½•è°ƒç”¨

[.fragment]
[source,cpp]
----
Fibonacci<10>::value // 55
Fibonacci_v<10> // 55
----

[.fragment]
TIP: 1. çº¦å®š [.blue]*å°–æ‹¬å·* ä¸ºæ¨¡æ¿å…ƒå‡½æ•°Fè°ƒç”¨ï¼Œ`value` ä½œä¸ºå‡½æ•°çš„ [.blue]*è¿”å›å€¼* +
2. æ¨¡æ¿å…ƒå‡½æ•°ååç¼€ `_v` ä¸ºå…¶åˆ«å: `F_v<IN>` ï¼Œé¿å…å†™ä¸€é•¿ä¸² `F<IN>::value` çš„çƒ¦æ¼
--

[.columns]
=== æ¨¡æ¿å…ƒç¼–ç¨‹ï¼šç±»å‹è®¡ç®—
[.column]
--
è®¡ç®—ç±»å‹ `T` çš„æŒ‡é’ˆç±»å‹ `T*`
[.fragment]
[source,cpp]
----
template <typename T> // <1>
struct AddPointer {   // <2>
    using type = T*;  // <3>
};

template <typename T>
using AddPointer_t =
    typename AddPointer<T>::type; // <4>
----
[.fragment]
<1> æ¨¡æ¿å…ƒå‡½æ•° [.blue]*è¾“å…¥* ç±»å‹Tï¼Œ`typename` è¡¨æ˜è¾“å…¥å‚æ•°æ˜¯ [.blue]*ç±»å‹*
<2> æ¨¡æ¿å…ƒå‡½æ•°å
<3> æ¨¡æ¿å…ƒå‡½æ•° [.blue]*è¾“å‡º* è¿”å› [.blue]*ç±»å‹* `type`
<4> åˆ«åï¼Œæ–¹ä¾¿è°ƒç”¨
--

[.column]
--

[.fragment]
icon:question[role="orange"]
å¦‚ä½•è°ƒç”¨

[.fragment]
[source,cpp]
----
typename AddPointer<int>::type px =
    new int{5};
AddPointer_t<int> px2 = new int{5};
----

[.fragment]
TIP: 1. çº¦å®š [.blue]*å°–æ‹¬å·* ä¸ºæ¨¡æ¿å…ƒå‡½æ•°Fè°ƒç”¨ï¼Œ`type` ä½œä¸ºå‡½æ•°çš„ [.blue]*è¿”å›ç±»å‹* +
2. æ¨¡æ¿å…ƒå‡½æ•°ååç¼€ `_t` ä¸ºå…¶åˆ«å: `F_t<IN>` ï¼Œé¿å…äº†å†™ä¸€é•¿ä¸² `typename F<IN>::type` çš„çƒ¦æ¼
--

== æ¨¡æ¿å…ƒç¼–ç¨‹ï¼šåŸºç¡€æ•°æ®ç±»å‹
[.fragment]
å¤åˆæ•°æ®ç±»å‹ï¼šTypeList

[%step]
* è¾“å…¥å¤šä¸ª *ç±»å‹* å‚æ•°ï¼šT1, T2, ...
* è¾“å‡ºä¸€ä¸ª TypeList ç±»å‹

[.fragment]
[source,cpp]
----
template <typename ...Ts> // <1>
struct TypeList {
    using type = TypeList<Ts...>; // <2>
    constexpr static size_t size = sizeof...(Ts); // <3>
};
----

[.fragment]
<1> è¾“å…¥å‚æ•°ï¼Œ...Ts [.blue]#æ¨¡æ¿å‚æ•°åŒ…# å£°æ˜ï¼Œè¡¨ç¤ºæ¥æ”¶ä»»æ„å¤šçš„ç±»å‹å‚æ•°ï¼š T1, T2, T3, ...
<2> è¾“å‡ºç±»å‹ï¼ŒTs... è¡¨ç¤ºå±•å¼€ [.blue]#æ¨¡æ¿å‚æ•°åŒ…#ï¼Œå±•å¼€åä¸ºT1, T2, T3, ...
<3> åˆ—è¡¨é•¿åº¦ï¼Œ`sizeof...` æ“ä½œç¬¦æ±‚å‚æ•°åŒ…ä¸ªæ•°

=== TypeList
åŸºæœ¬æ“ä½œ

[%step]
* å‘TypeListå°¾éƒ¨æ’å…¥ä¸€äº›ç±»å‹: `append`
* ç±»å‹å‚æ•°è½¬å‘: `exportTo`
* åˆ¤æ–­å½“å‰ç±»å‹æ˜¯å¦ä¸º TypeList: `IsTypeList`
* åˆ¤æ–­ç±»å‹æ˜¯å¦åœ¨TypeListä¸­: `Elem`
* é«˜é˜¶å‡½æ•°
** `Map`
** `Filter`
** `Fold`

=== append
å‘TypeListå°¾éƒ¨æ’å…¥ä¸€äº›ç±»å‹

[.fragment]
[source,cpp]
----
template <typename ...Ts>
struct TypeList {
  template <typename ...T> // <1>
  using append = TypeList<Ts..., T...>; // <2>
};
----

[.fragment]
<1> è¾“å…¥ä¸€äº›éœ€è¦æ’å…¥çš„ç±»å‹å‚æ•° `T...`
<2> è¾“å‡ºæ’å…¥ç±»å‹ä¹‹åçš„TypeList

[.fragment]
icon:question[role="orange"]
å¦‚ä½•è°ƒç”¨

[.fragment]
[source,cpp]
----
TypeList<int, char>::append<long, double> // TypeList<int, char, long, double>
----

=== exportTo
ç±»å‹å‚æ•°è½¬å‘

[.fragment]
å°† `TypeList<Ts...>` å‚æ•°è½¬å‘è‡³å…¶ä»–æ¨¡æ¿ç±»ï¼Œä¾‹å¦‚è½¬æˆï¼š `std::tuple<Ts...>`

[.fragment]
[source,cpp]
----
template <typename ...Ts>
struct TypeList {
    template <template<typename...> typename T> // <1>
    using exportTo = T<Ts...>; // <2>
};
----

[.fragment]
<1> è¾“å…¥ä¸€ä¸ªæ¨¡æ¿ç±» T
<2> è¾“å‡ºè½¬å‘ç±»å‹å‚æ•°åçš„æ¨¡æ¿ç±» T<Ts...>

[.fragment]
NOTE: `template<typename ...> typename T` è¡¨ç¤ºæ¨¡æ¿ç±» `T` æ¥æ”¶å¯å˜ç±»å‹å‚æ•°

[.fragment]
icon:question[role="orange"]
å¦‚ä½•è°ƒç”¨

[.fragment]
[source,cpp]
----
TypeList<int, char>::exportTo<std::tuple> // std::tuple<int, char>
TypeList<int, char>::exportTo<std::variant> // std::variant<int, char>
----

=== IsTypeList
åˆ¤æ–­å½“å‰ç±»å‹æ˜¯å¦ä¸º TypeList

[.fragment]
[source,cpp]
----
template<typename IN> // <1>
struct IsTypeList {
    constexpr static bool value = false; // <2>
};

template<typename ...Ts>
struct IsTypeList<TypeList<Ts...>> { // <3>
    constexpr static bool value = true;
};

template<typename IN>
constexpr bool IsTypeList_v = IsTypeList<IN>::value;
----

[.fragment]
<1> è¾“å…¥ç±»å‹å‚æ•° IN
<2> é»˜è®¤è®¤ä¸ºè¯¥ç±»å‹ä¸æ˜¯TypeList
<3> æ¨¡å¼åŒ¹é…ï¼Œå½“ç±»å‹å‚æ•°INå’ŒTypeListç±»å‹ä¸€è‡´æ—¶ï¼Œè¿”å› true

[.fragment]
icon:question[role="orange"]
å¦‚ä½•è°ƒç”¨

[.fragment]
[source,cpp]
----
IsTypeList_v<int>; // false
IsTypeList_v<TypeList<int>>; // true
----

=== Elem
åˆ¤æ–­ç±»å‹æ˜¯å¦åœ¨TypeListä¸­
[.fragment]
[source,cpp]
----
template<typename IN, typename E> // <1>
struct Elem {
    static constexpr bool value = false; // <2>
};

template<typename E, typename ...Ts>
struct Elem<TypeList<Ts...>, E> {
    static constexpr bool value = (std::is_same_v<E, Ts> || ...); // <3>
};

template<typename IN, typename E>
constexpr bool Elem_v = Elem<IN, E>::value;
----

[.fragment]
<1> è¾“å…¥ä¸¤ä¸ªç±»å‹å‚æ•°ï¼šIN, E
<2> é»˜è®¤è®¤ä¸ºEä¸å­˜åœ¨äºINä¸­
<3> æ¨¡å¼åŒ¹é…ï¼Œè‹¥INç±»å‹ä¸ºTypeListï¼Œåˆ™å…¶ä¸€ä¸ªä¸ªç±»å‹ä¸EåŒ¹é…

[.fragment]
icon:question[role="orange"]
å¦‚ä½•è°ƒç”¨

[.fragment]
[source,cpp]
----
Elem_v<TypeList<int>, int>; // true
Elem_v<TypeList<int>, float>; // false
----

== é«˜é˜¶å‡½æ•°
æ•°å­¦å’Œè®¡ç®—æœºç§‘å­¦å®šä¹‰å¦‚ä¸‹é«˜é˜¶å‡½æ•°ï¼š

[.fragment]
* è¾“å…¥çš„å‚æ•°ä¸ºå‡½æ•°
* è¾“å‡ºçš„å‚æ•°ä¸ºå‡½æ•°

[.fragment]
å¸¸ç”¨åˆ°çš„æœ‰ï¼š

[.fragment]
.Sort
[source,cpp]
----
template< class RandomIt, class Compar>
void sort(RandomIt first, RandomIt last,
    Compare comp); // <1>
----

[.fragment]
<1> sortä¸ºé«˜é˜¶å‡½æ•°ï¼Œå…¶è¾“å…¥å‚æ•°ä¸º `comp` å‡½æ•°

=== Mapé«˜é˜¶å‡½æ•°

* è¾“å…¥ä¸€ä¸ªåˆ—è¡¨å’Œå‡½æ•° f
* è¾“å‡ºå¯¹åˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ è¿›è¡Œfå‡½æ•°è°ƒç”¨åçš„åˆ—è¡¨

[.fragment]
image::Mapping-steps-loillibe-new.gif[100%,80%]

=== Filteré«˜é˜¶å‡½æ•°

* è¾“å…¥ä¸€ä¸ªåˆ—è¡¨å’Œè°“è¯å‡½æ•°P
* å¯¹åˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ è¿›è¡Œè¿‡æ»¤æ“ä½œï¼Œè¾“å‡ºåªä¿ç•™è°“è¯å‡½æ•°ä¸ºçœŸçš„å…ƒç´ çš„åˆ—è¡¨

[.fragment]
image::Filter-steps-loillierbe.gif[100%,80%]

[.columns]
=== Foldé«˜é˜¶å‡½æ•°
[.column]
--
* è¾“å…¥ä¸€ä¸ªåˆ—è¡¨ï¼ŒäºŒå…ƒå‡½æ•°fï¼Œå’Œåˆå€¼init
* è¾“å‡ºä¸€ä¸ªå…ƒç´ ï¼Œç»“æœä¸ºåˆ—è¡¨æ¯ä¸ªå…ƒç´ ä¸äºŒå…ƒå‡½æ•°é€’å½’è°ƒç”¨åçš„ç»“æœ
--

[.column.is-one-third]
--
[.fragment]
image::fold.jpg[]
--

== é«˜é˜¶å‡½æ•°
[quote, Conor Hoekstra, 'https://github.com/codereport/Talks/raw/master/2020-09-CppCon/SICP/Structure%20and%20Interpretation%20of%20Computer%20Programs%20-%20SICP.pdf[Structure and Interpretation of Computer Programs - SICP]']
____
Richard Waters (1979) developed a program that automatically analyzes traditional Fortran programs, viewing them in terms of *maps*, *filters*, and *accumulations*. He found that fully *90 percent* of the code in the Fortran Scientific Subroutine Package fits neatly into this paradigm. One of the reasons for the success of Lisp as a programming language is that lists provide a standard medium for expressing ordered collections so that they can be manipulated using higher-order operations. The programming language APL owes much of its power and appeal to a similar choice. In APL all data are represented as arrays, and there is a universal and convenient set of generic operators for all sorts of array operations.
____

=== Mapå®ç°
[source.fragment, cpp]
----
template<typename IN, template <typename> class F> // <1>
struct Map; // <2>

template<template <typename> class F, typename ...Ts>
struct Map<TypeList<Ts...>, F> {
    using type = TypeList<typename F<Ts>::type...>; // <3>
};

template<typename IN, template <typename> class F>
using Map_t = typename Map<IN, F>::type;
----

[.fragment]
<1> è¾“å…¥ç±»å‹å‚æ•° IN å’Œ å…ƒå‡½æ•° F
<2> å£°æ˜ä¸€ä¸ªå…ƒå‡½æ•°Map
<3> æ¨¡å¼åŒ¹é…å½“INç±»å‹ä¸ºTypeListæ—¶ï¼Œå¯¹å…¶æ¯ä¸ª `Ts...` å…ƒç´ è¿›è¡Œå…ƒå‡½æ•°è°ƒç”¨

[.fragment]
NOTE: 1. `template <typename> class F` ä¸ºå…ƒå‡½æ•°å£°æ˜ï¼Œè¡¨ç¤ºè¯¥å‡½æ•°è¾“å…¥ä¸€ä¸ªç±»å‹å‚æ•° +
2. `typename F<Ts>::type` è¡¨ç¤ºå¯¹å…ƒå‡½æ•° F è°ƒç”¨ï¼Œè¾“å…¥ä¸€ä¸ªç±»å‹å‚æ•° `Ts`ï¼Œè¿”å›è°ƒç”¨åçš„ç±»å‹å‚æ•° `::type` +
3. `typename F<Ts>::type...` å±•å¼€åç»“æœä¸º `typename F<T1>::type, typename F<T2>::type, typename F<T3>::type, ...`

=== Filterå®ç°
[source.column.fragment,cpp]
----
template<typename IN, template <typename> class P, typename OUT = TypeList<>> // <1>
struct Filter {
    using type = OUT; // <2>
};

template<template <typename> class P, typename OUT, typename H, typename ...Ts>
class Filter<TypeList<H, Ts...>, P, OUT> {
    using tails = TypeList<Ts...>; // <3>
public:
    using type = typename std::conditional_t<P<H>::value, // <4>
          Filter<tails, P, typename OUT::template append<H>>,
          Filter<tails, P, OUT>>::type;
};

template<typename IN, template <typename> class P>
using Filter_t = typename Filter<IN, P>::type;
----

[.fragment]
<1> è¾“å…¥ç±»å‹å‚æ•° IN å’Œ è°“è¯å‡½æ•° P
<2> é»˜è®¤è¿”å›ç±»å‹ä¸ºç©º TypeList; åˆ—è¡¨ä¸ºç©ºæ—¶é€’å½’ç»ˆæ­¢è¿”å›å½“å‰ OUT TypeList
<3> æ¨¡å¼åŒ¹é…å½“ç±»å‹å‚æ•° IN ä¸º *éç©º* TypeListæ—¶ï¼Œ`tails` å–é™¤äº†ç¬¬ä¸€ä¸ªå…ƒç´ åå‰©ä¸‹å…ƒç´ ç»„æˆçš„TypeList
<4> å¯¹å½“å‰åˆ—è¡¨ç¬¬ä¸€ä¸ªå‚æ•° H è¿›è¡Œ P å‡½æ•°è°ƒç”¨ï¼Œæ ¹æ®çœŸå‡åˆ¤æ–­è¦ä¸è¦æŠŠç»“æœæ”¾åˆ° OUT TypeList

[.fragment]
NOTE: 1. Filterå®ç°é‡‡ç”¨äº†å°¾é€’å½’æ–¹å¼ï¼Œå¯èƒ½æœ‰åŠ©äºç¼–è¯‘å™¨æé«˜ç¼–è¯‘é€Ÿåº¦ +
2. `P<H>::value` è¡¨ç¤ºå¯¹å…ƒå‡½æ•°Pçš„è°ƒç”¨ï¼Œè¾“å…¥ä¸€ä¸ªç±»å‹å‚æ•° Hï¼Œè¾“å‡ºå…¶å¸ƒå°”å€¼ `::value` +
3. å¯¹ OUT TypeListè¿›è¡Œappendå‚æ•° Hï¼Œå› ä¸º `append` ä¹Ÿæ˜¯ä¸ªæ¨¡æ¿å…ƒå‡½æ•°ï¼ŒåµŒå¥—äºç±»TypeListä¸­ï¼Œéœ€è¦å†™æˆ `typename OUT::template append<H>` ï¼Œå¯ä»¥çœ‹æˆæ˜¯ `out.append(h)` å½¢å¼

=== Foldå®ç°
[source.column.fragment,cpp]
----
template<typename IN, typename INIT, template<typename, typename> class OP> // <1>
struct Fold { using type = INIT; }; <2>

template<typename IN, typename INIT, template<typename, typename> class OP>
using Fold_t = typename Fold<IN, INIT, OP>::type;

template<typename ACC, template<typename, typename> class OP,
    typename H, typename ...Ts>
struct Fold<TypeList<H, Ts...>, ACC, OP> {
    using type = Fold_t<TypeList<Ts...>, typename OP<ACC, H>::type, OP>; // <3>
};
----

[.fragment]
<1> è¾“å…¥ç±»å‹å‚æ•° INï¼Œåˆå§‹ç±»å‹å‚æ•° INIT, äºŒå…ƒå‡½æ•° OP
<2> é»˜è®¤è¿”å›åˆå€¼ï¼›åˆ—è¡¨ä¸ºç©ºæ—¶é€’å½’ç»ˆæ­¢è¿”å›å½“å‰ INIT å‚æ•°
<3> å¯¹å½“å‰å‚æ•° H æ‰§è¡ŒäºŒå…ƒå‡½æ•° OP, å…¶è¿”å›ç±»å‹æ›´æ–° INIT å‚æ•°

[.fragment]
NOTE: 1. `template <typename, typename> class OP` ä¸ºå…ƒå‡½æ•°å£°æ˜ï¼Œä¸¤ä¸ª `typename` è¯´æ˜è¯¥å‡½æ•°è¾“å…¥ä¸¤ä¸ªç±»å‹å‚æ•° +
2. `typename OP<ACC, H>::type` è¡¨ç¤ºå¯¹å…ƒå‡½æ•° OP è°ƒç”¨ï¼Œè¾“å…¥ä¸¤ä¸ªç±»å‹å‚æ•° ACC, H ï¼Œè¿”å›è°ƒç”¨åçš„ç±»å‹å‚æ•° `::type`

== TypeListå®æˆ˜

* è¿æ¥ä¸¤ä¸ªTypeList: `Concat`
* å¿«é€Ÿæ’åº: `QuickSort`
* æ±‚å›¾å…¨å±€æœ€çŸ­è·¯å¾„ï¼ŒåŠ¨é™ç»“åˆ

== Concat
è¿æ¥ä¸¤ä¸ªTypeList: `Concat`

[.fragment]
[source,cpp]
----
template<typename IN, typename IN2> // <1>
class Concat {
    template<typename ACC, typename E> // <2>
    struct Append {
        using type = typename ACC::template append<E>;
    };
public:
    using type = Fold_t<IN2, IN, Append>; // <3>
};

template<typename IN, typename IN2>
using Concat_t = typename Concat<IN, IN2>::type;
----

[.fragment]
<1> è¾“å…¥ä¸¤ä¸ªTypeList: IN, IN2
<2> Append äºŒå…ƒæ“ä½œè¾“å…¥ä¸¤ä¸ªå‚æ•°ï¼Œä¸€ä¸ª ACC TypeListï¼Œä¸€ä¸ªç±»å‹å‚æ•° Eï¼Œé€šè¿‡è°ƒç”¨TypeListçš„ `append` å…ƒå‡½æ•°
<3> Fold é«˜é˜¶å‡½æ•°è°ƒç”¨ï¼Œè¾“å…¥ IN2ï¼Œåˆå€¼INï¼ŒäºŒå…ƒæ“ä½œ Appendï¼Œå¯¹IN2 TypeListçš„æ¯ä¸ªå…ƒç´ è¿›è¡Œ Append è°ƒç”¨


[.fragment]
icon:question[role="orange"]
å¦‚ä½•è°ƒç”¨

[.fragment]
[source,cpp]
----
Concat_t<TypeList<int, char>, TypeList<float>> // TypeList<int, char, float>
----

=== Concat 2
icon:question[role="orange"]
æœ‰æ²¡æœ‰å…¶ä»–è§£æ³•

[.fragment]
[source,cpp]
----
template<typename IN, typename IN2>
struct Concat;

template<typename ...Ts, typename ...Ts2>
struct Concat<TypeList<Ts...>, TypeList<Ts2...>> { // <1>
    using type = TypeList<Ts..., Ts2...>; // <2>
};

template<typename IN, typename IN2>
using Concat_t = typename Concat<IN, IN2>::type;
----

[.fragment]
<1> æ¨¡å¼åŒ¹é…ä¸¤ä¸ªTypeListï¼Œå¾—åˆ°å„è‡ªæ¨¡æ¿å‚æ•°åŒ… Ts, Ts2
<2> ç»“æœä¸ºä¸¤ä¸ªTypeListçš„å‚æ•°åŒ…éƒ½å±•å¼€åæ”¾åˆ°ä¸€èµ·

=== Concat 3
icon:question[role="orange"]
è¿˜æœ‰æ²¡æœ‰å…¶ä»–è§£æ³•

[.fragment]
[source,cpp]
----
template<typename IN, typename IN2>
struct Concat {
    using type = typename IN2::template exportTo<IN::template append>; // <1>
};

template<typename IN, typename IN2>
using Concat_t = typename Concat<IN, IN2>::type;
----

[.fragment]
<1> ä½¿ç”¨å‚æ•°è½¬å‘å‡½æ•°exportToï¼Œå°†IN2çš„å‚æ•°è½¬å‘åˆ°INçš„appendå‡½æ•°ä¸Šå»

[.fragment]
NOTE: 1. è¿™é‡Œå°†exportToå½“åšé«˜é˜¶å‡½æ•°ä½¿ç”¨ï¼Œå…¶è¾“å…¥ä¸€ä¸ªå‡½æ•° IN::appendï¼Œå°†è‡ªèº«çš„å‚æ•°è½¬è°ƒåˆ°è¿™ä¸ªå‡½æ•°ä¸Š +
2. ç”±äºINæ˜¯æ¨¡æ¿ç±»å‹å‚æ•°ï¼Œappend åˆæ˜¯æ¨¡æ¿å…ƒå‡½æ•°ï¼Œéœ€è¦å†™æˆ `IN::template append`

== QuickSort


