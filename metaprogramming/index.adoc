= C++æ¨¡æ¿å…ƒç¼–ç¨‹
:customcss: ../presentation.css
:revealjsdir: ../node_modules/reveal.js
:revealjs_plugins: ../presentation_plugins.js
:revealjs_plugins_configuration: ../presentation_plugins_conf.js
:revealjs_theme: serif
:highlightjs-theme: https://cdn.jsdelivr.net/npm/highlight.js@10.2.1/styles/atom-one-light.css
:highlightjs-languages: cpp
:source-highlighter: highlightjs
:revealjs_history: true
:revealjs_pdfseparatefragments: false
:revealjs_transition: zoom
:revealjs_slideNumber: c/t
:revealjs_fragmentInURL: true
:icons: font
:stem:
Netcan {docdate} @Shanghai

[subtitle]#template <typename ğŸ˜€>#

== æ¨¡æ¿ä»‹ç»

[%step]
* èµ·åˆä¸ºäº†æ”¯æŒæ³›å‹æ›¿ä»£å®è€Œè®¾è®¡çš„è¯­æ³•
* ç±»å‹å®‰å…¨ï¼Œç¼–è¯‘æœŸæå‰æ£€æŸ¥é”™è¯¯
* äººä»¬æ— æ„ä¸­å‘ç°å¯ä»¥ç”¨äº [red]*ç¼–è¯‘æœŸ* è®¡ç®—
* è¯­è¨€æ ‡å‡†å‘å±•ä¸æ–­å®Œå–„å…ƒç¼–ç¨‹ä½“éªŒ

== æ³›å‹ç®—æ³• & å®

[.fragment]
[source,cpp]
----
#define MAX(X, Y) (((X) > (Y)) ? (X) : (Y))
MAX(a++, b++) // (((a++) > (b++)) ? (a++) : (b++))
MAX(0, "123") // runtime error
----

[.fragment]
[source,cpp,subs="none"]
----
void qsort( void *ptr, size_t count, size_t size,
    int (*comp)(const <mark>void *</mark>, const <mark>void *</mark>) );
----

[.fragment]
[source,cpp]
----
int values[] = { 88, 56, 100, 2, 25 };
int cmpfunc (const void* a, const void* b) {
   return ( *(int*)a - *(int*)b );
}
qsort(values, 5, sizeof(int), cmpfunc);
----

=== æ³›å‹ç®—æ³• & æ¨¡æ¿å‡½æ•°
[.fragment]
[source,cpp]
----
template<typename T>
T max(T&& a, T&& b) {
    return a > b ? a : b;
}
----

[.fragment]
[source,cpp]
----
max(0, "123"); // error: no matching function for call to 'max(int, const char [4])'
----

[.fragment]
[source,cpp]
----
template<class RandomIt, class Compare>
void sort(RandomIt first, RandomIt last, Compare comp);
----

[.fragment]
[source,cpp]
----
int values[] = { 88, 56, 100, 2, 25 };
std::sort(values, values + 5, [](int a, int b) {
    return a < b;
});
----

=== æ³›å‹å®¹å™¨ & å®
[source,cpp]
----
// collection.h
struct Collection_ ## TYPE {
 TYPE *array; // <1>
 size_t size, n;
};

#ifdef INSTANCE // <2>
Collection_ ## TYPE make_Collection_ ## TYPE(size_t sz) {
    // ...
}
#endif
----
[.fragment]
<1> ç±»å‹å‚æ•° `TYPE`
<2> å®ä¾‹åŒ–å‡½æ•°

=== æ³›å‹å®¹å™¨ & å®
[source,cpp]
----
// main.cpp
#define INSTANCE

#define TYPE int // <1>
#include "collection.h"
#undef TYPE

#define TYPE string // <1>
#include "collection.h"
#undef TYPE

int main() {
    Collection_int lstInt = make_Collection_int(5); // <2>
    Collection_double lstDouble = make_Collection_double(5);
}
----
[.fragment]
<1> å®ä¾‹åŒ–ç±»å‹ `Collection_int`, `Collection_string`
<2> å®ä¾‹åŒ–æˆå‘˜å‡½æ•°

=== æ³›å‹å®¹å™¨ & æ¨¡æ¿
[source,cpp]
----
// collection.h
template <typename T> // <1>
class Collection {
    T* array;
    size_t size, n;
public:
    Collection(size_t sz) {
        // ...
    }
};

// main.cpp
int main() {
    Collection<int> lstInt(5); // <2>
    Collection<double> lstDouble(5); // <2>
}
----
[.fragment]
<1> æ¨¡æ¿å‚æ•° `T`
<2> å®ä¾‹åŒ–ç±»å‹ `Collection<int>`, `Collection<double>`

== é›¶æˆæœ¬æŠ½è±¡
[quote, Bjarne Stroustrup, 'http://www.stroustrup.com/ETAPS-corrected-draft.pdf[Foundations of C++]']
____
C++ implementations obey the zero-overhead principle:
What you donâ€™t use, you donâ€™t pay for. And further: What you do use, you couldnâ€™t hand code any better.
____

[.notes]
--
C++ç‰¹æ€§å¼•è¿›åŸåˆ™ï¼Œå¾—éµå®ˆä¸ä¼šå¸¦æ¥é¢å¤–å¼€é”€ï¼Œä¸è®ºæ—¶é—´ä¸Šè¿˜æ˜¯ç©ºé—´ä¸Šï¼Œéƒ½æ¯”ç¨‹åºçŒ¿è‡ªå·±å®ç°ç±»ä¼¼çš„ç‰¹æ€§è¦å¥½ï¼ˆè‡³å°‘ä¸å·®ï¼‰

ç„¶è€ŒRTTIå’Œå¼‚å¸¸è¿èƒŒäº†è¿™ä¸ªåŸåˆ™ï¼Œæ‰€ä»¥ç¼–è¯‘å™¨éƒ½æœ‰å¼€å…³å…³æ‰è¿™ç‰¹æ€§ã€‚
--

== å…ƒç¼–ç¨‹ & Metaprogramming

[%step]
* ç¼–è¯‘å™¨è§£ææ‰§è¡Œä»£ç ï¼Œå¹¶ *ç”Ÿæˆ* ä»£ç ã€æ•°æ®
* å°†è¿è¡Œæ—¶é€»è¾‘æŒªåˆ°ç¼–è¯‘æ—¶è®¡ç®—ï¼Œå®ç°é›¶æˆæœ¬æŠ½è±¡
* è¿è¡Œæ—¶æ‹¥æœ‰æ”¹å˜ç»“æ„çš„èƒ½åŠ›ï¼ŒåŠ¨é™ç»“åˆ

=== å…ƒç¼–ç¨‹ & æµæ´¾
[%step]
* https://www.youtube.com/watch?v=PJwd4JLYJJY[Constexpr all the things!]
* æ¨¡æ¿å…ƒç¼–ç¨‹
* ä¸¤è€…ç»“åˆ

=== Constexpr all the things!
image::constexpr-all-the-things.png[80%,80%]

[.notes]
--
constexprç›®å‰è¿˜ä¸æˆç†Ÿï¼Œè¦æ±‚å¤ªé«˜ï¼ŒC++20æ”¯æŒç¼–è¯‘æœŸåˆ†é…å†…å­˜åï¼Œå°±èƒ½å¢åŠ ä½¿ç”¨é¢äº†ï¼Œé™ä½é—¨æ§›ã€‚
--

[.columns]
=== æ¨¡æ¿å…ƒç¼–ç¨‹
[.column]
--
è¿è¡Œæ—¶äº¤äº’

[%step]
* æ•°å€¼
* å¯¹è±¡
--

[.column]
--
ç¼–è¯‘æ—¶è®¡ç®—ï¼ˆå¸¸é‡ï¼‰

[%step]
* æ•°å€¼
* ç±»å‹
* å¯¹è±¡ (C++20)
--

=== æ¨¡æ¿å…ƒç¼–ç¨‹
å‡½æ•°å¼ç¼–ç¨‹èŒƒå¼

[%step]
* æ— å‰¯ä½œç”¨çº¯å‡½æ•°
* å»¶è¿Ÿè®¡ç®—
* æ¨¡å¼åŒ¹é…

[.notes]
--
ç”±æœ€åŸºæœ¬çš„å‡½æ•°ï¼Œé€šè¿‡å‡½æ•°ç»„åˆå®ç°å¤æ‚é€»è¾‘
--

[.columns]
=== æ¨¡æ¿å…ƒç¼–ç¨‹ï¼šæ•°å€¼è®¡ç®—
[.column]
--
è®¡ç®—Fibonacciæ•°åˆ—: stem:[f(n) = f(n-1) + f(n-2)]
[.fragment]
[source,cpp]
----
template <size_t N> // <1>
struct Fibonacci {  // <2>
    constexpr static size_t value = // <3>
        Fibonacci<N - 1>::value +
        Fibonacci<N - 2>::value;
};

template <> struct Fibonacci<0> {   // <4>
    constexpr static size_t value = 0;
};

template <> struct Fibonacci<1> {   // <4>
    constexpr static size_t value = 1;
}

template<size_t N>
constexpr size_t Fibonacci_v = Fibonacci<N>::value; // <5>
----
--

[.column.is-one-third]
--
[.fragment]
<1> æ¨¡æ¿å…ƒå‡½æ•° [.blue]*è¾“å…¥* å‚æ•°Nï¼Œ`size_t` è¡¨æ˜è¾“å…¥å‚æ•°ä¸º [.blue]*å€¼*
<2> æ¨¡æ¿å…ƒå‡½æ•°å `Fibonacci`
<3> æ¨¡æ¿å…ƒå‡½æ•° [.blue]*è¾“å‡º* è¿”å› [.blue]*å€¼* `value`
<4> æ¨¡å¼åŒ¹é…ï¼Œå‡½æ•°é€’å½’çš„è¾¹ç•Œæ¡ä»¶
<5> åˆ«åï¼Œæ–¹ä¾¿è°ƒç”¨

[.fragment]
icon:question[role="orange"]
å¦‚ä½•è°ƒç”¨

[.fragment]
[source,cpp]
----
Fibonacci<10>::value // 55
Fibonacci_v<10> // 55
----

[.fragment]
TIP: 1. çº¦å®š [.blue]*å°–æ‹¬å·* ä¸ºæ¨¡æ¿å…ƒå‡½æ•°Fè°ƒç”¨ï¼Œ`value` ä½œä¸ºå‡½æ•°çš„ [.blue]*è¿”å›å€¼* +
2. æ¨¡æ¿å…ƒå‡½æ•°ååç¼€ `_v` ä¸ºå…¶åˆ«å: `F_v<IN>` ï¼Œé¿å…å†™ä¸€é•¿ä¸² `F<IN>::value` çš„çƒ¦æ¼
--

[.columns]
=== æ¨¡æ¿å…ƒç¼–ç¨‹ï¼šç±»å‹è®¡ç®—
[.column]
--
è®¡ç®—ç±»å‹ `T` çš„æŒ‡é’ˆç±»å‹ `T*`
[.fragment]
[source,cpp]
----
template <typename T> // <1>
struct AddPointer {   // <2>
    using type = T*;  // <3>
};

template <typename T>
using AddPointer_t =
    typename AddPointer<T>::type; // <4>
----
[.fragment]
<1> æ¨¡æ¿å…ƒå‡½æ•° [.blue]*è¾“å…¥* ç±»å‹Tï¼Œ`typename` è¡¨æ˜è¾“å…¥å‚æ•°æ˜¯ [.blue]*ç±»å‹*
<2> æ¨¡æ¿å…ƒå‡½æ•°å
<3> æ¨¡æ¿å…ƒå‡½æ•° [.blue]*è¾“å‡º* è¿”å› [.blue]*ç±»å‹* `type`
<4> åˆ«åï¼Œæ–¹ä¾¿è°ƒç”¨
--

[.column]
--

[.fragment]
icon:question[role="orange"]
å¦‚ä½•è°ƒç”¨

[.fragment]
[source,cpp]
----
typename AddPointer<int>::type px =
    new int{5};
AddPointer_t<int> px2 = new int{5};
----

[.fragment]
TIP: 1. çº¦å®š [.blue]*å°–æ‹¬å·* ä¸ºæ¨¡æ¿å…ƒå‡½æ•°Fè°ƒç”¨ï¼Œ`type` ä½œä¸ºå‡½æ•°çš„ [.blue]*è¿”å›ç±»å‹* +
2. æ¨¡æ¿å…ƒå‡½æ•°ååç¼€ `_t` ä¸ºå…¶åˆ«å: `F_t<IN>` ï¼Œé¿å…äº†å†™ä¸€é•¿ä¸² `typename F<IN>::type` çš„çƒ¦æ¼
--

== æ¨¡æ¿å…ƒç¼–ç¨‹ï¼šåŸºç¡€æ•°æ®ç±»å‹
[.fragment]
å¤åˆæ•°æ®ç±»å‹ï¼šTypeList

[%step]
* è¾“å…¥å¤šä¸ª *ç±»å‹* å‚æ•°ï¼šT1, T2, ...
* è¾“å‡ºä¸€ä¸ª TypeList ç±»å‹

[.fragment]
[source,cpp]
----
template <typename ...Ts> // <1>
struct TypeList {
    using type = TypeList<Ts...>; // <2>
    constexpr static size_t size = sizeof...(Ts); // <3>
};
----

[.fragment]
<1> è¾“å…¥å‚æ•°ï¼Œ...Ts [.blue]#æ¨¡æ¿å‚æ•°åŒ…# å£°æ˜ï¼Œè¡¨ç¤ºæ¥æ”¶ä»»æ„å¤šçš„ç±»å‹å‚æ•°ï¼š T1, T2, T3, ...
<2> è¾“å‡ºç±»å‹ï¼ŒTs... è¡¨ç¤ºå±•å¼€ [.blue]#æ¨¡æ¿å‚æ•°åŒ…#ï¼Œå±•å¼€åä¸ºT1, T2, T3, ...
<3> åˆ—è¡¨é•¿åº¦ï¼Œ`sizeof...` æ“ä½œç¬¦æ±‚å‚æ•°åŒ…ä¸ªæ•°

=== TypeList
åŸºæœ¬æ“ä½œ

[%step]
* å‘TypeListå°¾éƒ¨æ’å…¥ä¸€äº›ç±»å‹: `append`
* ç±»å‹å‚æ•°è½¬å‘: `exportTo`
* é«˜é˜¶å‡½æ•°
** `Map`
** `Filter`
** `Fold`

=== append
å‘TypeListå°¾éƒ¨æ’å…¥ä¸€äº›ç±»å‹

[.fragment]
[source,cpp]
----
template <typename ...Ts>
struct TypeList {
  template <typename ...T> // <1>
  using append = TypeList<Ts..., T...>; // <2>
};
----

[.fragment]
<1> è¾“å…¥ä¸€äº›éœ€è¦æ’å…¥çš„ç±»å‹å‚æ•° `T...`
<2> è¾“å‡ºæ’å…¥ç±»å‹ä¹‹åçš„TypeList

[.fragment]
icon:question[role="orange"]
å¦‚ä½•è°ƒç”¨

[.fragment]
[source,cpp]
----
TypeList<int, char>::append<long, double> // TypeList<int, char, long, double>
----

=== exportTo
ç±»å‹å‚æ•°è½¬å‘

[.fragment]
å°† `TypeList<Ts...>` å‚æ•°è½¬å‘è‡³å…¶ä»–æ¨¡æ¿ç±»ï¼Œä¾‹å¦‚è½¬æˆï¼š `std::tuple<Ts...>`

[.fragment]
[source,cpp]
----
template <typename ...Ts>
struct TypeList {
    template <template<typename...> typename T> // <1>
    using exportTo = T<Ts...>; // <2>
};
----

[.fragment]
<1> è¾“å…¥ä¸€ä¸ªæ¨¡æ¿ç±» T
<2> è¾“å‡ºè½¬å‘ç±»å‹å‚æ•°åçš„æ¨¡æ¿ç±» T<Ts...>

[.fragment]
NOTE: `template<typename ...> typename T` è¡¨ç¤ºæ¨¡æ¿ç±» `T` æ¥æ”¶å¯å˜ç±»å‹å‚æ•°

[.fragment]
icon:question[role="orange"]
å¦‚ä½•è°ƒç”¨

[.fragment]
[source,cpp]
----
TypeList<int, char>::exportTo<std::tuple> // std::tuple<int, char>
TypeList<int, char>::exportTo<std::variant> // std::variant<int, char>
----

== é«˜é˜¶å‡½æ•°
æ•°å­¦å’Œè®¡ç®—æœºç§‘å­¦å®šä¹‰å¦‚ä¸‹é«˜é˜¶å‡½æ•°ï¼š

[.fragment]
* è¾“å…¥çš„å‚æ•°ä¸ºå‡½æ•°
* è¾“å‡ºçš„å‚æ•°ä¸ºå‡½æ•°

[.fragment]
å¸¸ç”¨åˆ°çš„æœ‰ï¼š

[.fragment]
.Sort
[source,cpp]
----
template< class RandomIt, class Compar>
void sort(RandomIt first, RandomIt last,
    Compare comp); // <1>
----

[.fragment]
<1> sortä¸ºé«˜é˜¶å‡½æ•°ï¼Œå…¶è¾“å…¥å‚æ•°ä¸º `comp` å‡½æ•°

=== Mapé«˜é˜¶å‡½æ•°
* è¾“å…¥ä¸€ä¸ªåˆ—è¡¨å’Œå‡½æ•° f
* è¾“å‡ºå¯¹åˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ è¿›è¡Œfå‡½æ•°è°ƒç”¨åçš„åˆ—è¡¨

[.fragment]
image::Mapping-steps-loillibe-new.gif[100%,80%]

=== Filteré«˜é˜¶å‡½æ•°

* è¾“å…¥ä¸€ä¸ªåˆ—è¡¨å’Œè°“è¯å‡½æ•°P
* å¯¹åˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ è¿›è¡Œè¿‡æ»¤æ“ä½œï¼Œè¾“å‡ºåªä¿ç•™è°“è¯å‡½æ•°ä¸ºçœŸçš„å…ƒç´ çš„åˆ—è¡¨

[.fragment]
image::Filter-steps-loillierbe.gif[100%,80%]

[.columns]
=== Foldé«˜é˜¶å‡½æ•°
[.column]
--
* è¾“å…¥ä¸€ä¸ªåˆ—è¡¨ï¼ŒäºŒå…ƒå‡½æ•°fï¼Œå’Œåˆå€¼init
* è¾“å‡ºä¸€ä¸ªå…ƒç´ ï¼Œç»“æœä¸ºåˆ—è¡¨æ¯ä¸ªå…ƒç´ ä¸äºŒå…ƒå‡½æ•°é€’å½’è°ƒç”¨åçš„ç»“æœ
--

[.column.is-one-third]
--
[.fragment]
image::fold.jpg[]
--

[.column]
--
[.fragment]
image::fold2.jpg[]
--

=== Map/Filter/Fold
[.fragment]
map([ğŸ‚, ğŸ¥”, ğŸ”, ğŸŒ½], çƒ¹é¥ª) [.fragment]#=> [ğŸ”, ğŸŸ, ğŸ—, ğŸ¿]#

[.fragment]
filter([ğŸ”, ğŸŸ, ğŸ—, ğŸ¿], ç´ é£Ÿ) [.fragment]#=> [ğŸŸ, ğŸ¿]#

[.fragment]
fold([ğŸ”, ğŸŸ, ğŸ—, ğŸ¿], ğŸº, åƒ) [.fragment]#=> ğŸ’©#

== é«˜é˜¶å‡½æ•°
[quote, Conor Hoekstra, 'https://github.com/codereport/Talks/raw/master/2020-09-CppCon/SICP/Structure%20and%20Interpretation%20of%20Computer%20Programs%20-%20SICP.pdf[Structure and Interpretation of Computer Programs - SICP]']
____
Richard Waters (1979) developed a program that automatically analyzes traditional Fortran programs, viewing them in terms of *maps*, *filters*, and *accumulations*. He found that fully *90 percent* of the code in the Fortran Scientific Subroutine Package fits neatly into this paradigm. One of the reasons for the success of Lisp as a programming language is that lists provide a standard medium for expressing ordered collections so that they can be manipulated using higher-order operations. The programming language APL owes much of its power and appeal to a similar choice. In APL all data are represented as arrays, and there is a universal and convenient set of generic operators for all sorts of array operations.
____

=== Mapå®ç°
[source.fragment, cpp]
----
template<typename IN, template <typename> class F> // <1>
struct Map; // <2>

template<template <typename> class F, typename ...Ts>
struct Map<TypeList<Ts...>, F> {
    using type = TypeList<typename F<Ts>::type...>; // <3>
};

template<typename IN, template <typename> class F>
using Map_t = typename Map<IN, F>::type;
----

[.fragment]
<1> è¾“å…¥ç±»å‹å‚æ•° IN å’Œ å…ƒå‡½æ•° F
<2> å£°æ˜ä¸€ä¸ªå…ƒå‡½æ•°Map
<3> æ¨¡å¼åŒ¹é…å½“INç±»å‹ä¸ºTypeListæ—¶ï¼Œå¯¹å…¶æ¯ä¸ª `Ts...` å…ƒç´ è¿›è¡Œå…ƒå‡½æ•°è°ƒç”¨

[.fragment]
NOTE: 1. `template <typename> class F` ä¸ºå…ƒå‡½æ•°å£°æ˜ï¼Œè¡¨ç¤ºè¯¥å‡½æ•°è¾“å…¥ä¸€ä¸ªç±»å‹å‚æ•° +
2. `typename F<Ts>::type` è¡¨ç¤ºå¯¹å…ƒå‡½æ•° F è°ƒç”¨ï¼Œè¾“å…¥ä¸€ä¸ªç±»å‹å‚æ•° `Ts`ï¼Œè¿”å›è°ƒç”¨åçš„ç±»å‹å‚æ•° `::type` +
3. `typename F<Ts>::type...` å±•å¼€åç»“æœä¸º `typename F<T1>::type, typename F<T2>::type, typename F<T3>::type, ...`

=== Filterå®ç°
[source.column.fragment,cpp]
----
template<typename IN, template <typename> class P, typename OUT = TypeList<>> // <1>
struct Filter { using type = OUT; }; // <2>

template<template <typename> class P, typename OUT, typename H, typename ...Ts>
struct Filter<TypeList<H, Ts...>, P, OUT>:
    std::conditional_t<P<H>::value,
        Filter<TypeList<Ts...>, P, typename OUT::template append<H>>,
        Filter<TypeList<Ts...>, P, OUT>> { }; // <3>

template<typename IN, template <typename> class P>
using Filter_t = typename Filter<IN, P>::type;
----

[.fragment]
<1> è¾“å…¥ç±»å‹å‚æ•° IN å’Œ è°“è¯å‡½æ•° P
<2> é»˜è®¤è¿”å›ç±»å‹ä¸ºç©º TypeList; åˆ—è¡¨ä¸ºç©ºæ—¶é€’å½’ç»ˆæ­¢è¿”å›å½“å‰ OUT TypeList
<3> å¯¹å½“å‰åˆ—è¡¨ç¬¬ä¸€ä¸ªå‚æ•° H è¿›è¡Œ P å‡½æ•°è°ƒç”¨ï¼Œæ ¹æ®çœŸå‡åˆ¤æ–­è¦ä¸è¦æŠŠç»“æœæ”¾åˆ° OUT TypeList

[.fragment]
NOTE: 1. Filterå®ç°é‡‡ç”¨äº†å°¾é€’å½’æ–¹å¼ï¼Œå¯èƒ½æœ‰åŠ©äºç¼–è¯‘å™¨æé«˜ç¼–è¯‘é€Ÿåº¦ +
2. ä½¿ç”¨ç»§æ‰¿æ–¹å¼çœå»äº†å†™ `using type = ...` çš„ä»£ç  +
3. `P<H>::value` è¡¨ç¤ºå¯¹å…ƒå‡½æ•°Pçš„è°ƒç”¨ï¼Œè¾“å…¥ä¸€ä¸ªç±»å‹å‚æ•° Hï¼Œè¾“å‡ºå…¶å¸ƒå°”å€¼ `::value` +
4. å¯¹ OUT TypeListè¿›è¡Œappendå‚æ•° Hï¼Œå› ä¸º `append` ä¹Ÿæ˜¯ä¸ªæ¨¡æ¿å…ƒå‡½æ•°ï¼Œå†…åµŒäºç±»TypeListä¸­ï¼Œéœ€è¦å†™æˆ `typename OUT::template append<H>` ï¼Œå¯ä»¥çœ‹æˆæ˜¯ `out.append(h)` å½¢å¼

=== Foldå®ç°
[source.column.fragment,cpp]
----
template<typename IN, typename INIT, template<typename, typename> class OP> // <1>
struct Fold { using type = INIT; }; <2>

template<typename IN, typename INIT, template<typename, typename> class OP>
using Fold_t = typename Fold<IN, INIT, OP>::type;

template<typename ACC, template<typename, typename> class OP,
    typename H, typename ...Ts>
struct Fold<TypeList<H, Ts...>, ACC, OP>:
    Fold<TypeList<Ts...>, typename OP<ACC, H>::type, OP> {}; // <3>
----

[.fragment]
<1> è¾“å…¥ç±»å‹å‚æ•° INï¼Œåˆå§‹ç±»å‹å‚æ•° INIT, äºŒå…ƒå‡½æ•° OP
<2> é»˜è®¤è¿”å›åˆå€¼ï¼›åˆ—è¡¨ä¸ºç©ºæ—¶é€’å½’ç»ˆæ­¢è¿”å›å½“å‰ INIT å‚æ•°
<3> å¯¹å½“å‰å‚æ•° H æ‰§è¡ŒäºŒå…ƒå‡½æ•° OP, å…¶è¿”å›ç±»å‹æ›´æ–° INIT å‚æ•°

[.fragment]
NOTE: 1. `template <typename, typename> class OP` ä¸ºå…ƒå‡½æ•°å£°æ˜ï¼Œä¸¤ä¸ª `typename` è¯´æ˜è¯¥å‡½æ•°è¾“å…¥ä¸¤ä¸ªç±»å‹å‚æ•° +
2. `typename OP<ACC, H>::type` è¡¨ç¤ºå¯¹å…ƒå‡½æ•° OP è°ƒç”¨ï¼Œè¾“å…¥ä¸¤ä¸ªç±»å‹å‚æ•° ACC, H ï¼Œè¿”å›è°ƒç”¨åçš„ç±»å‹å‚æ•° `::type`

== TypeListå®æˆ˜

* è¿æ¥ä¸¤ä¸ªTypeList: `Concat`
* åˆ¤æ–­ç±»å‹æ˜¯å¦åœ¨TypeListä¸­: `Elem`
* TypeListå»é‡: `Unique`
* å¿«é€Ÿæ’åº: `QuickSort`
* æ±‚å›¾å…¨å±€æœ€çŸ­è·¯å¾„ï¼ŒåŠ¨é™ç»“åˆ

== Concat
è¿æ¥ä¸¤ä¸ªTypeList

[.fragment]
[source,cpp]
----
template<typename IN, typename IN2>    // <1>
class Concat {
    template<typename ACC, typename E> // <2>
    struct Append: ACC::template append<E> { };
public:
    using type = Fold_t<IN2, IN, Append>; // <3>
};

template<typename IN, typename IN2>
using Concat_t = typename Concat<IN, IN2>::type;
----

[.fragment]
<1> è¾“å…¥ä¸¤ä¸ªTypeList: IN, IN2
<2> å®šä¹‰ Append äºŒå…ƒæ“ä½œè¾“å…¥ä¸¤ä¸ªå‚æ•°ï¼Œä¸€ä¸ª ACC TypeListï¼Œä¸€ä¸ªç±»å‹å‚æ•° Eï¼Œé€šè¿‡è°ƒç”¨TypeListçš„ `append` å…ƒå‡½æ•°
<3> [.blue]#Fold# é«˜é˜¶å‡½æ•°è°ƒç”¨ï¼Œè¾“å…¥ IN2ï¼Œåˆå€¼INï¼ŒäºŒå…ƒæ“ä½œ Appendï¼Œå¯¹IN2 TypeListçš„æ¯ä¸ªå…ƒç´ è¿›è¡Œ Append è°ƒç”¨


[.fragment]
icon:question[role="orange"]
å¦‚ä½•è°ƒç”¨

[.fragment]
[source,cpp]
----
Concat_t<TypeList<int, char>, TypeList<float>> // TypeList<int, char, float>
----

=== Concat 2
icon:question[role="orange"]
æœ‰æ²¡æœ‰å…¶ä»–è§£æ³•

[.fragment]
[source,cpp]
----
template<typename IN, typename IN2>
struct Concat;

template<typename ...Ts, typename ...Ts2>
struct Concat<TypeList<Ts...>, TypeList<Ts2...>> { // <1>
    using type = TypeList<Ts..., Ts2...>; // <2>
};

template<typename IN, typename IN2>
using Concat_t = typename Concat<IN, IN2>::type;
----

[.fragment]
<1> æ¨¡å¼åŒ¹é…ä¸¤ä¸ªTypeListï¼Œå¾—åˆ°å„è‡ªæ¨¡æ¿å‚æ•°åŒ… Ts, Ts2
<2> ç»“æœä¸ºä¸¤ä¸ªTypeListçš„å‚æ•°åŒ…éƒ½å±•å¼€åæ”¾åˆ°ä¸€èµ·

=== Concat 3
icon:question[role="orange"]
è¿˜æœ‰æ²¡æœ‰å…¶ä»–è§£æ³•

[.fragment]
[source,cpp]
----
template<typename IN, typename IN2>
struct Concat: IN2::template exportTo<IN::template append> { }; // <1>

template<typename IN, typename IN2>
using Concat_t = typename Concat<IN, IN2>::type;
----

[.fragment]
<1> ä½¿ç”¨å‚æ•°è½¬å‘å‡½æ•°exportToï¼Œå°†IN2çš„å‚æ•°è½¬å‘åˆ°INçš„appendå‡½æ•°ä¸Šå»

[.fragment]
NOTE: 1. è¿™é‡Œå°†exportToå½“åšé«˜é˜¶å‡½æ•°ä½¿ç”¨ï¼Œå…¶è¾“å…¥ä¸€ä¸ªå‡½æ•° IN::appendï¼Œå°†è‡ªèº«çš„å‚æ•°è½¬è°ƒåˆ°è¿™ä¸ªå‡½æ•°ä¸Š +
2. ç”±äºINæ˜¯æ¨¡æ¿ç±»å‹å‚æ•°ï¼Œappend åˆæ˜¯æ¨¡æ¿å…ƒå‡½æ•°ï¼Œéœ€è¦å†™æˆ `IN::template append`

== Elem
åˆ¤æ–­ç±»å‹æ˜¯å¦åœ¨TypeListä¸­
[.fragment]
[source,cpp]
----
template<typename IN, typename E> // <1>
class Elem {
    template<typename ACC, typename T>
    struct FindE: std::conditional_t<ACC::value, ACC, std::is_same<T, E>> {} ; // <2>

    using Found = Fold_t<IN, std::false_type, FindE>; // <3>
public:
    static constexpr bool value = Found::value; // <4>
};

template<typename IN, typename E>
constexpr bool Elem_v = Elem<IN, E>::value;
----
[.fragment]
<1> è¾“å…¥ä¸¤ä¸ªç±»å‹å‚æ•°ï¼šIN TypeList, å¾…æŸ¥æ‰¾ç±»å‹E
<2> å®šä¹‰äºŒå…ƒæ“ä½œFindEï¼Œè‹¥ACCä¸ºçœŸåˆ™è¯´æ˜å·²ç»æ‰¾åˆ°è¿‡ï¼Œç›´æ¥è¿”å›ï¼›å¦åˆ™åˆ¤æ–­å½“å‰ç±»å‹å‚æ•°æ˜¯å¦ä¸Eç›¸ç­‰
<3> [.blue]#Fold# æ“ä½œï¼Œè¾“å…¥IN TypeListï¼Œåˆå€¼ç±»å‹ä¸ºfalse_typeï¼ŒäºŒå…ƒæ“ä½œFindE
<4> ä»å¸ƒå°”ç±»å‹å¾—åˆ°å…¶å€¼

[.fragment]
icon:question[role="orange"]
å¦‚ä½•è°ƒç”¨

[.fragment]
[source,cpp]
----
Elem_v<TypeList<int>, int>; // true
Elem_v<TypeList<int>, float>; // false
----

=== Elem 2
icon:question[role="orange"]
è¿˜æœ‰æ²¡æœ‰å…¶ä»–è§£æ³•
[.fragment]
[source,cpp]
----
template<typename IN, typename E>
struct Elem {
    constexpr static bool value = false; // <1>
};

template<typename E, typename ...Ts>
struct Elem<TypeList<Ts...>, E> {
    constexpr static bool value = (std::is_same_v<E, Ts> || ...); // <2>
};

template<typename IN, typename E>
constexpr bool Elem_v = Elem<IN, E>::value;
----

[.fragment]
<1> é»˜è®¤è®¤ä¸ºEä¸å­˜åœ¨äºINä¸­
<2> æ¨¡å¼åŒ¹é…ï¼Œè‹¥INç±»å‹ä¸ºTypeListï¼Œåˆ™å…¶ä¸€ä¸ªä¸ªç±»å‹ä¸EåŒ¹é…

[.fragment]
TIP: å¾—ç›ŠäºC++17çš„æŠ˜å è¡¨è¾¾å¼([.blue]#fold# expression)ï¼š `(pack op ... )`ï¼Œä½¿è¿™ç§æ–¹å¼å¯è¡Œ

== Unique
å¯¹TypeListå»é‡æ“ä½œ

[.fragment]
[source,cpp]
----
template<typename IN> // <1>
class Unique {
    template<typename ACC, typename E>                // <2>
    struct Append: std::conditional_t<Elem_v<ACC, E>, // <3>
        ACC, typename ACC::template append<E>> {};
public:
    using type = Fold_t<IN, TypeList<>, Append>;      // <4>
};

template<typename IN>
using Unique_t = typename Unique<IN>::type;
----

[.fragment]
<1> è¾“å…¥å¾…å»é‡çš„IN TypeList
<2> å®šä¹‰äºŒå…ƒæ“ä½œAppendï¼Œè¾“å…¥ACC TypeListå’Œå¾…æ’å…¥ç±»å‹å‚æ•°E
<3> å½“å‰ä»…å½“Eä¸å­˜åœ¨äºACCä¸­æ’å…¥åˆ—è¡¨
<4> [.blue]#Fold# é«˜é˜¶å‡½æ•°è°ƒç”¨ï¼Œè¾“å…¥å¾…å»é‡çš„IN TypeListï¼Œåˆå€¼ç©ºè¡¨ï¼ŒäºŒå…ƒæ“ä½œ Appendï¼Œå¯¹IN TypeListçš„æ¯ä¸ªå…ƒç´ è¿›è¡Œ Append è°ƒç”¨

== QuickSort
[%step]
* é€‰å–è¡¨ä¸­Pivotå…ƒç´ ï¼Œä»¥Pivotä¸ºåˆ’åˆ†ç‚¹ [.fragment.blue]#Filteræ“ä½œ#
** å°äºPivotçš„æ‰€æœ‰å…ƒç´ æ”¾åˆ°å·¦è¾¹å½¢æˆæ–°è¡¨
** å¤§äºç­‰äºPivotçš„æ‰€æœ‰å…ƒç´ æ”¾åˆ°å³è¾¹å½¢æˆæ–°è¡¨
* å¯¹å·¦å³ä¸¤ä¸ªè¡¨è¿›è¡Œé€’å½’QuickSortæ“ä½œåï¼Œè¿æ¥æˆè¡¨å¾—åˆ°æœ€ç»ˆæœ‰åºè¡¨ [.fragment.blue]#Foldæ“ä½œ#

[%step]
. {[.fragment.highlight-current-blue]*40*, 80, 30, 90, 10, 70, 50}
. {{[.fragment.highlight-current-blue]*30*, 10}, 40, {80, 90, 70, 50}}
. {{{10}, 30}, 40, {[.fragment.highlight-current-blue]*80*, 90, 70, 50}}
. {{{10}, 30}, 40, {{[.fragment.highlight-current-blue]*70*, 50}, 80, {90}}}
. {{{10}, 30}, 40, {{{50}, 70}, 80, {90}}}
. {10, 30, 40, 50, 70, 80, 90}

=== QuickSort
[.fragment]
[source,cpp]
----
template<typename IN, template<typename, typename> class CMP> // <1>
struct QuickSort { using type = TypeList<>; };                // <2>
template<typename IN, template<typename, typename> class CMP>
using QuickSort_t = typename QuickSort<IN, CMP>::type;

template<template<typename, typename> class CMP, typename PIVOT, typename ...Ts>
class QuickSort<TypeList<PIVOT, Ts...>, CMP> {
    using tails = TypeList<Ts...>;
    template<typename E>
    struct LT { constexpr static bool value = CMP<E, PIVOT>::value; };  // <3>
    template<typename E>
    struct GE { constexpr static bool value = !CMP<E, PIVOT>::value; }; // <3>

    using SmallerSorted = QuickSort_t<Filter_t<tails, LT>, CMP>; // <4>
    using BiggerSorted = QuickSort_t<Filter_t<tails, GE>, CMP>;  // <4>
public:
    using type = Concat_t<typename SmallerSorted::template append<PIVOT>, BiggerSorted>; // <5>
};
----
[.fragment]
<1> è¾“å…¥ä¸€ä¸ªIN TypeListï¼Œæ¯”è¾ƒå…ƒå‡½æ•°CMP
<2> é»˜è®¤è¿”å›ç©ºåˆ—è¡¨
<3> å®šä¹‰ä¸¤ä¸ªå…ƒå‡½æ•°LT/GTï¼Œç”¨äºå¾—åˆ°å’ŒPIVIOTæ¯”è¾ƒç»“æœ
<4> [.blue]#Filter# æ“ä½œå¾—åˆ°å·¦å³ä¸¤ä¸ªè¡¨ï¼Œå¯¹ä¸¤ä¸ªè¡¨è¿›è¡Œé€’å½’QuickSortæ“ä½œ
<5> è¿æ¥æˆè¡¨å¾—åˆ°æœ€ç»ˆæœ‰åºè¡¨

=== QuickSort
icon:question[role="orange"]
å¦‚ä½•è°ƒç”¨

[.fragment]
[source,cpp]
----
template<typename LHS, typename RHS> // <1>
struct SizeCmp {
    constexpr static bool value = sizeof(LHS) < sizeof(RHS); // <1>
};

QuickSort_t<
    TypeList<char, float, double, int, char>,
    SizeCmp> // TypeList<char, char, float, int, double>>
----

[.fragment]
<1> å®šä¹‰æ¯”è¾ƒå‡½æ•°ï¼Œè¾“å…¥ä¸¤ä¸ªç±»å‹ï¼Œæ ¹æ®ç±»å‹å¤§å°æ’åº

== å…¨å±€æœ€çŸ­è·¯å¾„
image::find_shortest_path.png[]

[%step]
- å­˜åœ¨ç¯ï¼šA->B->A
- A->Dæœ€çŸ­è·¯å¾„å…¶å®æ˜¯A->C->D
- D->Eä¸å¯è¾¾

=== ä¼ªä»£ç 
ä»»æ„ç»™å®šä¸¤ä¸ªç‚¹ï¼Œé‡‡ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œä¼ªä»£ç å¦‚ä¸‹

[.fragment]
[source,python]
----
def find_shortest_path(from, to, path = []):         // <1>
    if from == to: return path   # reach target      // <2>
    if from in path: return []   # find cycle        // <3>
    for each (from, v) in edges: # expand next nodes // <4>
        cur_path = from + find_shortest_path(v, to)  // <5>
        path = min(path, cur_path)                   // <6>
    return path
----
[.fragment]
<1> è¾“å…¥èµ·ç‚¹from, ç»ˆç‚¹to
<2> è‹¥æ‰¾åˆ°ç›®çš„åœ°toï¼Œè¿”å›å½“å‰è·¯å¾„
<3> è‹¥å½“å‰ç‚¹å­˜åœ¨å½“å‰è·¯å¾„ä¸­ï¼Œåˆ™é‡åˆ°äº†ç¯ï¼Œè¿”å›ç©ºè·¯å¾„
<4> ä»è¾¹é›†edgesæ‰¾åˆ°å½“å‰ç‚¹fromçš„é‚»æ¥è¾¹è¡¨ [.fragment.blue]#Filteræ“ä½œ# +
    ä»é‚»æ¥è¾¹è¡¨å¾—åˆ°é‚»æ¥ç‚¹è¡¨v [.fragment.blue]#Mapæ“ä½œ#
<5> æ›´æ–°å½“å‰è·¯å¾„curr_path
<6> æ±‚å‡ºæœ€çŸ­éç©ºè·¯å¾„ [.fragment.blue]#Foldæ“ä½œ#

=== ç”¨æˆ·ç•Œé¢

[.fragment]
[source,cpp]
----
template<char ID>
struct Node { constexpr static char id = ID; };
using A = Node<'A'>;
using B = Node<'B'>;
using C = Node<'C'>;
using D = Node<'D'>;
using E = Node<'E'>;

using g = Graph< // <1>
    link(node(A) -> node(B) -> node(C) -> node(D)),
    link(node(A) -> node(C)),  // test shortest path: A -> C -> D
    link(node(B) -> node(A)),  // test cycle
    link(node(A) -> node(E))>; // test D -> E unreachable

static_assert(g::getPath('A', 'D').sz == 3);    // compile-time test // <2>
auto path = g::getPath(argv[1][0], argv[2][0]); // runtime test      // <2>
std::cout << " path size: " << path.sz << std::endl;
----

[.fragment]
<1> ç”¨æˆ·æ„é€ è¾¹é›†ï¼Œè¿”å›Graphå¯¹è±¡
<2> Graphå¯¹è±¡ç”Ÿæˆçš„getPathæ¥å£æ—¢èƒ½ç”¨äºç¼–è¯‘æ—¶ï¼Œä¹Ÿèƒ½è¿è¡Œæ—¶

=== æ„é€ è¾¹é›†

[.fragment]
[source,cpp]
----
using g = Graph< // <1>
    link(node(A) -> node(B) -> node(C) -> node(D)),
    link(node(A) -> node(C)),  // test shortest path: A -> C -> D
    link(node(B) -> node(A)),  // test cycle
    link(node(A) -> node(E))>; // test D -> E unreachable
----

icon:angle-double-down[role="icon-center fragment"]

[.fragment]
[source,cpp]
----
using g = Graph<
    auto(*)(A) -> auto(*)(B) -> auto(*)(C) -> auto(*)(D) -> void,
    auto(*)(A) -> auto(*)(C) -> void,
    auto(*)(B) -> auto(*)(A) -> void,
    auto(*)(A) -> auto(*)(E) -> void>;
----

[.fragment]
TIP: `auto(*)(A) -> B` å£°æ˜ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆç±»å‹ï¼Œä¸º [.blue]#åç½®è¿”å›ç±»å‹# å†™æ³•ï¼Œé€šè¿‡åœ¨å‰é¢å£°æ˜ `auto` ï¼Œè¿™æ ·è¿”å›ç±»å‹å°±å¯ä»¥é€šè¿‡ç®­å¤´->å†™åˆ°åé¢

[.fragment]
NOTE: 1. ä¸ºäº†æ›´å¥½æè¿°å›¾ï¼Œæ­£å¥½ç”¨ä¸Š [.blue]#åç½®è¿”å›ç±»å‹# ä¸­çš„ç®­å¤´ç¬¦å· +
2. ç”±äºå‡½æ•°å¯ä»¥è¿”å›ä¸€ä¸ªå‡½æ•°ï¼Œæ‰€ä»¥å¯ä»¥ä¸²èµ·æ¥ï¼Œè¾¾åˆ°é“¾ `auto(\*)(A) -> auto(*)(B) -> auto(\*)\(C) -> auto(*)(D) -> void` æ•ˆæœ +
3. çº¦å®šé“¾æ¡æœ€åç”¨ `void` è¡¨ç¤ºç»“æŸ

=== è¾¹ç»“æ„
[.fragment]
[source,cpp]
----
template<typename F, typename T>
struct Edge {
    using From = F;
    using To = T;
};
----

[.fragment]
åŸºç¡€æ“ä½œ

[.fragment]
[source,cpp]
----
template<typename Node = void>
struct EdgeTrait {
    template<typename Edge> struct IsFrom // <1>
    { constexpr static bool value = std::is_same_v<typename Edge::From, Node>; };
    template<typename Edge> struct IsTo   // <1>
    { constexpr static bool value = std::is_same_v<typename Edge::To, Node>; };
    template<typename Edge> // <2>
    struct GetFrom { using type = typename Edge::From; };
    template<typename Edge> // <2>
    struct GetTo { using type = typename Edge::To; };
};
----

[.fragment]
<1> è¾“å…¥ä¸€ä¸ªèŠ‚ç‚¹Nodeï¼Œä¸€æ¡è¾¹Edgeï¼Œè¾“å‡ºè¯¥èŠ‚ç‚¹æ˜¯å¦ä¸ºEdgeçš„æºFromã€ç›®çš„ç‚¹To
<2> è¾“å…¥ä¸€æ¡è¾¹Edgeï¼Œè¾“å‡ºå®ƒçš„æºFromã€ç›®çš„ç‚¹To

[.fragment]
TIP: çº¦å®šç”¨ Trait åç¼€è¡¨æ˜ä¸ºä¸€ç»„ç±»å‹çš„å±æ€§ã€åŠ¨ä½œ

=== è§£æ„é“¾Chain
icon:question[role="orange"]
é“¾ `auto(\*)(A) -> auto(*)(B) -> auto(\*)\(C) -> auto(*)(D) -> void` +
icon:angle-double-down[role="icon-center"]
Edgeè¾¹è¡¨ `TypeList<Edge<A, B>, Edge<B, C>, Edge<C, D>>`

[.fragment]
å®šä¹‰ä¸€ä¸ªè§£æ„å‡½æ•°Chainï¼Œè¾“å…¥é“¾ï¼Œè¾“å‡ºEdgeè¡¨

[.fragment]
[source,cpp]
----
template<typename T, typename OUT = TypeList<>>
struct Chain;

template<typename F, typename OUT>
struct Chain<auto(*)(F) -> void, OUT> {
    using From = F;
    using type = OUT; // <1>
};

template<typename F, typename T, typename OUT>
struct Chain<auto(*)(F) -> T, OUT> {
private:
    using To = typename Chain<T, OUT>::From;
public:
    using From = F;
    using type = typename Chain<T,
          typename OUT::template append<Edge<From, To>>>::type; // <2>
};
----

[.fragment]
<1> é€’å½’è¾¹ç•Œæƒ…å†µï¼Œå½“é‡åˆ°é“¾å°¾ `void` ï¼Œè¿”å›å½“å‰è¾¹è¡¨
<2> å¸¸è§„æƒ…å†µï¼Œä¸æ–­æ„é€ Edgeè¾¹ï¼Œå­˜åˆ°è¾¹è¡¨OUT TypeListä¸­

=== è·å¾—è¾¹é›†

[.fragment]
[source,cpp]
----
template<typename... Chains> // <1>
class Graph {
    using Edges = Fold_t<    // <2>
        TypeList<typename Chain<Chains>::type...>,
        TypeList<>,
        Concat>;
    ...
};
----

[.fragment]
<1> ç”¨æˆ·è¾“å…¥é“¾æ¡é›†
<2> Chainå…ƒå‡½æ•°è§£æ„æ¯ä¸€æ¡é“¾æ¡å¾—åˆ°è¾¹è¡¨çš„é›†åˆï¼Œé€šè¿‡ [.blue]#Fold# æ“ä½œå±•å¼€å¾—åˆ°è¾¹é›†

=== ä¸¤ç‚¹é—´æœ€çŸ­è·¯å¾„
å…ƒå‡½æ•°PathFinderå£°æ˜å¦‚ä¸‹
[.fragment]
[source,cpp]
----
// def find_shortest_path(from, to, path = []):
template<typename FROM, typename TARGET,         // <1>
    typename PATH = TypeList<>, typename = void> // <2>
struct PathFinder;
----

[.fragment]
<1> è¾“å…¥ä¸¤ä¸ªç‚¹FROMï¼ŒTARGETï¼Œè¾“å‡ºä»–ä»¬ä¹‹é—´æœ€çŸ­è·¯å¾„
<2> PATHè·¯å¾„ç”¨äºåˆ¤æ–­æ˜¯å¦é‡åˆ°äº†ç¯ï¼›ç¬¬å››ä¸ªå‚æ•°ç”¨äºæ¨¡å¼åŒ¹é…ä¸­çš„æ¡ä»¶åˆ¤æ–­

[.fragment]
NOTE: æœ‰æ—¶å€™ `typename Cond = void` å¯¹ç±»å‹å‚æ•°å `Cond` ä¸å…³æ³¨æ—¶ï¼Œå¯ä»¥å†™æˆ `typename = void`

=== ä¸¤ç‚¹é—´æœ€çŸ­è·¯å¾„
[.fragment]
[source,cpp]
----
// if from == to: return path # reach target
template<typename TARGET, typename PATH>
struct PathFinder<TARGET, TARGET, PATH>: // <1>
    PATH::template append<TARGET> { };   // <2>
----

[.fragment]
<1> æ¨¡å¼åŒ¹é…ï¼Œå½“FROM == TARGETæ—¶ï¼Œåˆ°è¾¾ç»ˆç‚¹
<2> è¿”å›æœ€çŸ­è·¯å¾„

[.fragment]
[source,cpp]
----
// if from in path: return []   # find cycle
template<typename CURR_NODE, typename TARGET, typename PATH>
struct PathFinder<CURR_NODE, TARGET, PATH,
    std::enable_if_t<Elem_v<PATH, CURR_NODE>>>: // <1>
    TypeList<> {}; // return empty path // <2>
----

[.fragment]
<1> æ¨¡å¼åŒ¹é…ï¼Œå½“CURR_NODEå‡ºç°åœ¨å½“å‰è·¯å¾„ä¸­ï¼Œè¯´æ˜é‡åˆ°äº†ç¯
<2> è¿”å›ç©ºè·¯å¾„

=== ä¸¤ç‚¹é—´æœ€çŸ­è·¯å¾„
[.fragment]
[source,cpp]
----
template<typename CURR_NODE, typename TARGET, typename PATH>
class PathFinder<CURR_NODE, TARGET, PATH,
    std::enable_if_t<! std::is_same_v<CURR_NODE, TARGET>
        && !Elem_v<PATH, CURR_NODE>>> { // <1>
    using EdgesFrom = Filter_t<Edges, EdgeTrait<CURR_NODE>::template IsFrom>; // <2>
    // for each (from, v) in edges: # expand next nodes
    using NextNodes = Map_t<EdgesFrom, EdgeTrait<>::GetTo>; // <3>
    // cur_path = from + find_shortest_path(v, to)
    template<typename NEXT_NODE>
    struct GetPath: PathFinder<NEXT_NODE, TARGET,
        typename PATH::template append<CURR_NODE>> {};
    using AllPaths = Map_t<NextNodes, GetPath>; // <4>
    template<typename ACC, typename Path> struct MinPath:
        std::conditional_t<(ACC::size == 0 ||
            ((ACC::size > Path::size) && Path::size > 0)), Path, ACC> {};
public:
    // path = min(path, cur_path)
    using type = Fold_t<AllPaths, TypeList<>, MinPath>; // <5>
};
----

[.fragment]
<1> æ¨¡å¼åŒ¹é…ï¼Œå½“å‰ä»…å½“å½“å‰CURR_NODEèŠ‚ç‚¹ä¸æ˜¯ç»ˆç‚¹TARGETï¼Œå¹¶ä¸”ä¸æ˜¯ç¯æ—¶
<2> [.blue]#Filter# æ“ä½œï¼Œä»è¾¹é›†Edgesæ‰¾å‡ºé‚»æ¥CURR_NODEè¾¹
<3> [.blue]#Map# æ“ä½œï¼Œå¯¹è¾¹è¡¨æ¯ä¸€æ¡è¾¹è¿›è¡ŒGetToæ“ä½œï¼Œè·å–CURR_NODEé‚»æ¥ç‚¹è¡¨
<4> [.blue]#Map# æ“ä½œï¼Œå¯¹æ¯ä¸ªé‚»æ¥ç‚¹åšä¸ºèµ·ç‚¹è¿›è¡Œé€’å½’æ±‚æœ€çŸ­è·¯å¾„é›†
<5> [.blue]#Fold# æ“ä½œï¼Œå¯¹æ¯æ¡å¯è¡Œè·¯å¾„ï¼Œæ‰¾å‡ºæœ€çŸ­çš„é‚£æ¡ä½œä¸ºæœ€çŸ­è·¯å¾„

=== åŠ¨é™ç»“åˆ
icon:question[role="orange"]
è¿è¡Œæ—¶å¦‚ä½•æ±‚æœ€çŸ­è·¯å¾„

[%step]
- ç¼–è¯‘æœŸç”Ÿæˆæ‰€æœ‰èŠ‚ç‚¹é—´çš„æœ€çŸ­è·¯å¾„
- æä¾›æ¥å£ä¾›è¿è¡Œæ—¶æŸ¥è¡¨ï¼Œè¾“å…¥èµ·ç‚¹ã€ç»ˆç‚¹ï¼ŒæŸ¥å‡ºæœ€çŸ­è·¯å¾„

[.fragment]
icon:question[role="orange"]
å¦‚ä½•å¾—åˆ°æ‰€æœ‰èŠ‚ç‚¹é—´çš„ç»„åˆ

[.fragment]
å¯¹è¾¹é›†çš„èµ·ç‚¹è¡¨å’Œé‚»æ¥ç‚¹è¡¨åšç¬›å¡å°”ç§¯ï¼

[.fragment.icon-center]#{A->B, B->C}#
icon:angle-double-down[role="icon-center fragment"]
[.fragment.icon-center]#{A, B} x {B, C}#
icon:angle-double-down[role="icon-center fragment"]
[.fragment.icon-center]#{(A, B), (A, C), (B, B), (B, C)}#

=== ç¬›å¡å°”ç§¯
è¾“å…¥ä¸¤ä¸ªåˆ—è¡¨ï¼Œå¯¹ä¸¤ä¸ªåˆ—è¡¨ä¸­çš„å…ƒç´ ä¸¤ä¸¤ç»„åˆå¾—åˆ°åºå¯¹è¡¨

[.fragment]
[source,cpp]
----
template<typename A, typename B,
    template<typename, typename> class PAIR>
struct CrossProduct;

template<typename A, typename B, template<typename, typename> class PAIR>
using CrossProduct_t = typename CrossProduct<A, B, PAIR>::type;

template<typename A, typename B, template<typename, typename> class PAIR>
class CrossProduct {
    template<typename RESULT_OUTTER, typename TA>    // <1>
    struct OuterAppend {
        template<typename RESULT_INNER, typename TB> // <2>
        struct InnerAppend: RESULT_INNER::template append<PAIR<TA, TB>> { };
        using type = Fold_t<B, RESULT_OUTTER, InnerAppend>;
    };
public:
    using type = Fold_t<A, TypeList<>, OuterAppend>;
};
----

[.fragment]
<1> å¤–å±‚å¾ªç¯ï¼Œå¾—åˆ°ç±»å‹å‚æ•°TA
<2> å†…å±‚å¾ªç¯ï¼Œå¾—åˆ°ç±»å‹å‚æ•°TBï¼Œä¸¤ä¸¤ç»„åˆæˆåºå¯¹PAIR<TA, TB>ï¼Œæ”¾åˆ°RESULTè¡¨ä¸­

=== è·¯å¾„å­˜å‚¨
æšä¸¾å‡ºæ‰€æœ‰èŠ‚ç‚¹é—´çš„ç»„åˆæƒ…å†µ

[.fragment]
[source,cpp]
----
using AllPairs = CrossProduct_t<
    Unique_t<Map_t<Edges, EdgeTrait<>::GetFrom>>,
    Unique_t<Map_t<Edges, EdgeTrait<>::GetTo>>,
    std::pair>;
----

[.fragment]
è·¯å¾„æ•°æ®ç»“æ„
[.fragment]
[source,cpp]
----
template<typename NODE_TYPE>
struct Path {
    const NODE_TYPE* path;
    size_t sz;
};

template<typename NODE, typename... NODEs>
class PathStorage { // <1>
    using NODE_TYPE = std::decay_t<decltype(NODE::id)>;
    constexpr static NODE_TYPE pathStorage[] { NODE::id, NODEs::id... };
public:
    constexpr static Path<NODE_TYPE> path {
        .path = pathStorage,
        .sz   = sizeof...(NODEs) + 1,
    };
};
----

[.fragment]
<1> PathStorage<A, B, C>::path å­˜å‚¨ A->C ä¹‹é—´æœ€çŸ­è·¯å¾„

=== æœ€çŸ­è·¯å¾„è¡¨
æˆ‘ä»¬æœŸæœ›ç¼–è¯‘æœŸç”Ÿæˆå¦‚ä¸‹è¡¨ï¼Œä¾›è¿è¡Œæ—¶æŸ¥è¯¢

[.fragment]
[%autowidth, frame=none]
|===
|FROM|DST|MinPath
|A|B|PathStorage<A, B>::path
|A|C|PathStorage<A, C>::path
|A|D|PathStorage<A, C, D>::path
|A|A|PathStorage<A>::path
|A|E|PathStorage<A, E>::path
|===

[.fragment]
è¡¨é¡¹æ•°æ®ç»“æ„ï¼šPATH_PAIR: `std::pair<PAIR, PATH>` => `std::pair<std::pair<FROM, DST>, PATH>`

=== ç”Ÿæˆè·¯å¾„
è¾“å…¥ä¸¤èŠ‚ç‚¹åºå¯¹PAIRï¼Œè¾“å‡ºPATH_PAIRï¼Œ[.blue]#Map# æ“ä½œ

[.fragment]
[source,cpp]
----
template<typename PAIR>
struct GetPath {
    using type = std::pair<PAIR,
        typename PathFinder<typename PAIR::first_type,
                            typename PAIR::second_type>::type>;
};

using AllPaths = Map_t<AllPairs, GetPath>;
----

[.fragment]
åˆ é™¤ç©ºè·¯å¾„é¡¹ï¼Œ[.blue]#Filter# æ“ä½œ

[.fragment]
[source,cpp]
----
template<typename PATH_PAIR>
struct IsNonEmptyPath {
    constexpr static bool value = (PATH_PAIR::second_type::size > 0);
};

using AllNonEmptyPaths = Filter_t<AllPaths, IsNonEmptyPath>;
----

=== ç”Ÿæˆæ•°æ®è¡¨é¡¹
[.blue]#Map# æ“ä½œ

[.fragment]
[source,cpp]
----
template<typename PATH_PAIR>
struct SavePath {
    using type = std::pair<typename PATH_PAIR::first_type,
            typename PATH_PAIR::second_type::template exportTo<PathStorage>>; // <1>
};

using SavedPaths = Map_t<AllNonEmptyPaths, SavePath>;
----

[.fragment]
<1> è·¯å¾„æ•°æ®è½¬å‘è‡³ PathStorage ç±»ï¼Œè§¦å‘å­˜å‚¨

=== ç”Ÿæˆç¼–è¯‘æ—¶ã€è¿è¡Œæ—¶æ¥å£
[.fragment]
[source,cpp]
----
template<typename NODE_TYPE, typename FROM, typename TARGET, typename PATH>
constexpr static bool matchPath(NODE_TYPE from, NODE_TYPE to,
        Path<NODE_TYPE>& result, std::pair<std::pair<FROM, TARGET>, PATH>) {
    if (FROM::id == from && TARGET::id == to) { // <1>
        result = PATH::path;                    // <1>
        return true;
    }
    return false;
}

template<typename NODE_TYPE, typename ...PATH_PAIRs>
constexpr static void matchPath(NODE_TYPE from, NODE_TYPE to,
        Path<NODE_TYPE>& result, TypeList<PATH_PAIRs...>) {
    (matchPath(from, to, result, PATH_PAIRs{}) || ...); // <2>
}
----

[.fragment]
[source,cpp]
----
// export compile/run-time interface
template<typename NODE_TYPE>
constexpr static Path<NODE_TYPE> getPath(NODE_TYPE from, NODE_TYPE to) { // <3>
    Path<NODE_TYPE> result{};
    matchPath(from, to, result, SavedPaths{});
    return result;
}
----

[.fragment]
<1> å½“FROM/TARGETä¸è¡¨é¡¹åŒ¹é…æ—¶ï¼Œè¿”å›è·¯å¾„ result
<2> éå†æŸ¥è¡¨åŠ¨ä½œï¼Œç›´åˆ°æ‰¾åˆ°è·¯å¾„ä¸ºæ­¢
<3> ä¾›è¿è¡Œæ—¶ä½¿ç”¨

== è¯­è¨€å‘å±•å®Œå–„ä½“éªŒ

== ç»“è®º
[%step]
- åº“ã€æ¡†æ¶å¼€å‘è€…å¿…å¤‡æŠ€èƒ½
- æ›´é«˜çº§åˆ«æŠ½è±¡å±‚æ¬¡ï¼Œå®ç°é›¶æˆæœ¬æŠ½è±¡
- è®¾è®¡çµæ´»ç»„åˆã€ç±»å‹å®‰å…¨ã€å®¹æ˜“ä½¿ç”¨çš„æ¥å£
- é¢†åŸŸç‰¹å®šè¯­è¨€DSL

[state=thank]
== Thank you!


