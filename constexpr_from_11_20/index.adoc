= CONSTEXPR ä» 11 åˆ° 20
:customcss: ../presentation.css
:revealjsdir: ../node_modules/reveal.js
:revealjs_plugins: ../presentation_plugins.js
:revealjs_plugins_configuration: ../presentation_plugins_conf.js
:revealjs_theme: serif
:highlightjs-theme: https://cdn.jsdelivr.net/npm/highlight.js@10.2.1/styles/github-gist.css
:source-highlighter: highlightjs
:highlightjs-languages: cpp,x86asm,haskell
:revealjs_history: true
:revealjs_pdfseparatefragments: false
:revealjs_transition: slide
:revealjs_slideNumber: c/t
:revealjs_fragmentInURL: true
:icons: font
:stem:
Netcan {docdate} @Shanghai

[subtitle]#constexpr auto ğŸ˜€#

template metaprogramming is dead +
long live constexpr

include::../common/self_introduction.adoc[]

== è®®ç¨‹
* ç¼–è¯‘æ—¶è®¡ç®—ï¼ˆå…ƒç¼–ç¨‹ï¼‰
* æ¼”è¿›å†å²
* constexpr vs æ¨¡æ¿å…ƒ
* æ·±å…¥constexpr
* åº”ç”¨
* å±•æœ›æœªæ¥
* ç»“è®º

== ç¼–è¯‘æ—¶è®¡ç®—ï¼ˆå…ƒç¼–ç¨‹ï¼‰
* é›¶æˆæœ¬æŠ½è±¡
* ç¼–è¯‘æ—¶å¤šæ€ (eg. Policy Class, Tag Dispatcher, CRTP)
* å€¼è®¡ç®—
* ç±»å‹è®¡ç®—(Type Traits)
* ç±»å‹å®‰å…¨ (eg. å•ä½è¿ç®—, Phantom Types)
* å†…éƒ¨é¢†åŸŸç‰¹å®šè¯­è¨€(EDSL)

=== ç¼–è¯‘æ—¶è®¡ç®—ï¼ˆå…ƒç¼–ç¨‹ï¼‰& é£æ ¼
* æ¨¡æ¿å…ƒç¼–ç¨‹
* Constexpr all the things!
* ä¸¤è€…ç»“åˆ

[.columns]
== æ¼”è¿›å†å²
[.column]
--
æ¨¡æ¿å…ƒç¼–ç¨‹

* 1986 C++å¼•å…¥æ¨¡æ¿
* C++98 æ¨¡æ¿å®ä¾‹åŒ–
* C++11 æ¨¡æ¿ç±»åˆ«åã€å¯å˜æ¨¡æ¿å‚æ•°ã€static_assertã€decltypeã€type_traits
* C++14 decltype(auto)ã€integer_sequence
* C++17 ç±»æ¨¡æ¿å‚æ•°æ¨å¯¼CTADã€autoéç±»å‹å‚æ•°ã€void_t
* C++20 æ¦‚å¿µConceptã€æ”¾å®½éç±»å‹å‚æ•°
--

[.column]
--
constexpr

* C++11 å¼•å…¥constexprç®€å•å‡½æ•°
* C++14 æ”¾å¼€constexprçº¦æŸ, æ¨¡æ¿å˜é‡
* C++17 if constexprã€constexpr lambdaã€æŠ˜å è¡¨è¾¾å¼
* C++20 constexprå®¹å™¨ã€constexpr newã€constexprææ„å‡½æ•°ã€constexprè™šå‡½æ•°ã€consteval/constinitã€lambdaæ¨¡æ¿å‚æ•°
* constexpr STL algorithms
--

[.columns]
== constexpr vs æ¨¡æ¿å…ƒç¼–ç¨‹
[.column]
--
BrainFuckè¯­è¨€

* å›¾çµå®Œå¤‡
* 8ç§æ“ä½œç¬¦
* DSL

https://fatiherikli.github.io/brainfuck-visualizer/#PisrKysrKysrWzwrKysrKysrKys+LV08LiAgICAgICAgICAgICAgICAgOyBICj4+KysrKysrKysrK1s8KysrKysrKysrKz4tXTwrLiAgICAgICAgICAgIDsgZQo+PisrKysrKysrK1s8KysrKysrKysrKysrPi1dPC4gICAgICAgICAgICA7IGwKPj4rKysrKysrKytbPCsrKysrKysrKysrKz4tXTwuICAgICAgICAgICAgOyBsCj4+KysrKysrKysrK1s8KysrKysrKysrKys+LV08Ky4gICAgICAgICAgIDsgbwo+PisrKytbPCsrKysrKysrPi1dPC4gICAgICAgICAgICAgICAgICAgICA7Cj4+KysrKysrKysrKytbPCsrKysrKysrPi1dPC0uICAgICAgICAgICAgIDsgVwo+PisrKysrKysrKytbPCsrKysrKysrKysrPi1dPCsuICAgICAgICAgICA7IG8KPj4rKysrKysrKysrWzwrKysrKysrKysrKys+LV08LS0tLS0tLiAgICAgOyByCj4+KysrKysrKysrWzwrKysrKysrKysrKys+LV08LiAgICAgICAgICAgIDsgbAo+PisrKysrKysrKytbPCsrKysrKysrKys+LV08LiAgICAgICAgICAgICA7IGQKPj4rKysrKytbPCsrKysrKz4tXTwtLS0uICAgIC[brainfuck-visualizer]
--

[.column]
--
[cols="2"]
|===
| > |	++ptr;
| < |	--ptr;
| + |	++*ptr;
| - |	--*ptr;
| . |	putchar(*ptr);
| , |	*ptr = getchar();
| [ |	while (*ptr) {
| ] |	}

|===
--

=== BrainFuck: Hello world
[source,cpp]
----
puts( R"(
    >++++++++[<+++++++++>-]<.             ; H   (8*9     = 72)
    >>++++++++++[<++++++++++>-]<+.        ; e   (10*10+1 = 101)
    >>+++++++++[<++++++++++++>-]<.        ; l   (9*12    = 108)
    >>+++++++++[<++++++++++++>-]<.        ; l   (9*12    = 108)
    >>++++++++++[<+++++++++++>-]<+.       ; o   (10*11+1 = 111)
    >>++++[<++++++++>-]<.                 ; ' ' (4*8     = 32)
    >>+++++++++++[<++++++++>-]<-.         ; W   (11*8-1  = 87)
    >>++++++++++[<+++++++++++>-]<+.       ; o   (10*11+1 = 111)
    >>++++++++++[<++++++++++++>-]<------. ; r   (10*12-6 = 114)
    >>+++++++++[<++++++++++++>-]<.        ; l   (9*12    = 108)
    >>++++++++++[<++++++++++>-]<.         ; d   (10*10   = 100)
    >>++++++[<++++++>-]<---.              ; !   (6*6-3   = 33)
)"_brain_fuck );
----

== BrainFuckç¼–è¯‘å™¨ï¼šæ¨¡æ¿å…ƒè§£æ³•
åŸºç¡€å…ƒæ•°æ®ç»“æ„
[source,cpp]
----
template<char c>
using Cell = std::integral_constant<char, c>;

template<size_t P = 0, bool INLOOP = false, typename ...CELLs>
struct Machine {
    using type = Machine<P, INLOOP, CELLs...>;
    constexpr static bool InLoop = INLOOP;
};
----

=== BrainFuckç¼–è¯‘å™¨ï¼šæ¨¡æ¿å…ƒè§£æ³•
ç›¸å…³æ“ä½œ
[source,cpp,subs="verbatim,quotes"]
----
namespace MachineTrait {
    template<size_t N>
    struct *InitMachine*: Concat_t<Machine<0, 0, Cell<0>>, typename *InitMachine<N-1>*::type> {};
    template<> struct *InitMachine<0>: Machine<0, 0, Cell<0>>* {};

    template<typename MACHINE> struct Inc;
    template<typename MACHINE> using Inc_t = typename Inc<MACHINE>::type;
    template<size_t PC, bool INLOOP, typename C, typename... CELLs>
    struct Inc<Machine<PC, INLOOP, C, CELLs...>>:
        Concat_t<Machine<PC, INLOOP, C>, Inc_t<Machine<PC - 1, INLOOP, CELLs...>>> {};
    template<bool INLOOP, typename C, typename... CELLs>
    struct Inc<Machine<0, INLOOP, C, CELLs...>>:
        Machine<0, INLOOP, Cell< *C::value + 1* >, CELLs...> {};

    template<typename MACHINE>
    struct Left;
    template<typename MACHINE>
    using Left_t = typename Left<MACHINE>::type;
    template<size_t PC, bool INLOOP, typename... CELLs>
    struct Left<Machine<PC, INLOOP, CELLs...>>:
        Machine< *PC-1*, INLOOP, CELLs...> {};
};
----

=== BrainFuckç¼–è¯‘å™¨ï¼šæ¨¡æ¿å…ƒè§£æ³•
è§£æBrainFuckä»£ç ï¼šåŸºæœ¬æ“ä½œ
[source,cpp,subs="verbatim,quotes"]
----
template<typename MACHINE, bool skip, char ...cs>
struct BrainFuck: MACHINE {};
template<typename MACHINE, bool skip, char ...cs>
using BrainFuck_t = typename BrainFuck<MACHINE, skip, cs...>::type;

template<typename MACHINE, char ...cs>
struct BrainFuck<MACHINE, false, *'+'*, cs...>:
    BrainFuck_t<MachineTrait::Inc_t<MACHINE>, false, cs...> {};

template<typename MACHINE, char ...cs>
struct BrainFuck<MACHINE, false, *'-'*, cs...>:
    BrainFuck_t<MachineTrait::Dec_t<MACHINE>, false, cs...> {};

template<typename MACHINE, char ...cs>
struct BrainFuck<MACHINE, false, *'<'*, cs...>:
    BrainFuck_t<MachineTrait::Left_t<MACHINE>, false, cs...> {};

template<typename MACHINE, char ...cs>
struct BrainFuck<MACHINE, false, *'>'*, cs...>:
    BrainFuck_t<MachineTrait::Right_t<MACHINE>, false, cs...> {};
----

=== BrainFuckç¼–è¯‘å™¨ï¼šæ¨¡æ¿å…ƒè§£æ³•
è§£æBrainFuckä»£ç ï¼šå¾ªç¯ & åˆ†æ”¯
[source,cpp,subs="verbatim,quotes"]
----
template<typename MACHINE, char ...cs>
struct BrainFuck<MACHINE, false, *'['*, cs...> {
    using EnableLoopedMachine = MachineTrait::EnableLoop_t<MACHINE>;

    template<typename IN, bool = MachineTrait::IsZero_t<IN>::value>
    struct Select: BrainFuck_t<IN, true, cs...> {}; // skip
    template<typename IN> // loop
    struct Select<IN, false>: BrainFuck_t<IN, false, cs...> {};

    using Result = typename Select<EnableLoopedMachine>::type;

    template<typename IN, bool = (! MachineTrait::IsZero_t<IN>::value && IN::InLoop)>
    struct Loop: IN {};   // skip
    template<typename IN> // continue
    struct Loop<IN, true>: BrainFuck_t<IN, false, '[', cs...> {};

    using type = typename Loop<Result>::type;
};
----

=== BrainFuckç¼–è¯‘å™¨ï¼šæ¨¡æ¿å…ƒè§£æ³•
ä¿å­˜ç»“æœ
[source,cpp]
----
template<size_t PC, bool INLOOP, typename ...CELLs>
inline const auto ToStr(Machine<PC, INLOOP, CELLs...>) {
    constexpr const static char str[] = { CELLs::value ...  };
    return str;
}

template<typename T, T... cs>
constexpr auto operator ""_brain_fuck() {
    using Machine = MachineTrait::InitMachine_t<15>;
    using Result = BrainFuck_t<Machine, false, cs...>;

    return ToStr(Result{});
};
----

=== BrainFuckç¼–è¯‘å™¨ï¼šæ¨¡æ¿å…ƒè§£æ³•
å®Œæ•´ä»£ç ï¼š https://godbolt.org/z/GTKxhc[https://godbolt.org/z/GTKxhc]

ç”Ÿæˆä»£ç 
[source,x86asm,subs="verbatim,quotes"]
----
main:
    subq    $8, %rsp
    movl    $MachineTrait::ToStr<...>(Machine<...>)::str, %edi
    call    puts
    xorl    %eax, %eax
    addq    $8, %rsp
    ret
MachineTrait::ToStr<...>(Machine<...>)::str:
    .string *"Hello World!"*
    .string ""
    .string ""
    .string ""
----

== BrainFuckç¼–è¯‘å™¨ï¼šconstexprè§£æ³•
åŸºç¡€æ•°æ®ç»“æ„
[source,cpp]
----
template<size_t N>
class Stream {
public:
    constexpr void push(char c) { data_[idx_++] = c; }
    constexpr operator const char*() const { return data_; }
    constexpr size_t size() { return idx_; }
private:
    size_t idx_{};
    char data_[N]{};
};
----

=== BrainFuckç¼–è¯‘å™¨ï¼šconstexprè§£æ³•
é€’å½’ä¸‹é™è§£æå™¨
[source,cpp]
----
template<typename STREAM>
constexpr auto parse(const char* input, bool skip, char* cells,
        size_t& pc, STREAM&& output) -> size_t {
    const char* c = input;
    while(*c) {
        switch(*c) {
            case '+': if (!skip) ++cells[pc];            break;
            case '-': if (!skip) --cells[pc];            break;
            case '.': if (!skip) output.push(cells[pc]); break;
            case '>': if (!skip) ++pc;                   break;
            case '<': if (!skip) --pc;                   break;
            case '[': {
                while (!skip && cells[pc] != 0)
                    parse(c + 1, false, cells, pc, std::forward<STREAM>(output));
                c += parse(c + 1, true, cells, pc, std::forward<STREAM>(output)) + 1;
            } break;
            case ']': return c - input;
            default: break;
        }
        ++c;
    }
    return c - input;
}
----

=== BrainFuckç¼–è¯‘å™¨ï¼šconstexprè§£æ³•
æ•´åˆä¸€èµ·ï¼š
[source,cpp]
----
constexpr size_t CELL_SIZE = 16;
template<typename STREAM>
constexpr auto parse(const char* input, STREAM&& output) -> STREAM&& {
    char cells[CELL_SIZE]{};
    size_t pc{};
    parse(input, false, cells, pc, output);
    return std::forward<STREAM>(output);
}

template<size_t OUTPUT_SIZE = 15>
constexpr auto brain_fuck(const char* input) {
    return parse(input, Stream<OUTPUT_SIZE>{});
}
----

=== BrainFuckç¼–è¯‘å™¨ï¼šconstexprè§£æ³•
å®Œæ•´ä»£ç ï¼š https://godbolt.org/z/EYn7PG[https://godbolt.org/z/EYn7PG]

ç¼–è¯‘ã€è¿è¡Œæ—¶ä½¿ç”¨ï¼š
[source,cpp]
----
// compile time
constexpr auto res = brain_fuck(R"(
    ++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.
    >---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.
)");
puts(res);

// runtime
if (argc > 1) puts(brain_fuck(argv[1]));
----

=== BrainFuckç¼–è¯‘å™¨ï¼šconstexprè§£æ³•
[source,cpp,subs="verbatim,quotes"]
----
template<size_t *OUTPUT_SIZE* = 15>
constexpr auto brain_fuck(const char* input);
----

icon:question[role="orange"]
è‹¥OUTPUT_SIZEè¿‡å°ï¼Œä¼šæ€ä¹ˆæ ·

image::brain_fuck_buffer_overflow.png[]

icon:lightbulb-o[]
ç¼–è¯‘æŠ¥é”™ï¼Œ*ä¸å…è®¸å†…å­˜è¶Šç•Œub*

=== BrainFuckç¼–è¯‘å™¨ï¼šconstexprè§£æ³•
[source,cpp,subs="verbatim,quotes"]
----
template<size_t *OUTPUT_SIZE* = 15>
constexpr auto brain_fuck(const char* input);
----

icon:question[role="orange"]
å¦‚ä½•æå‰çŸ¥é“OUTPUT_SIZEæ‰€éœ€è¦å¤§å°

[source,cpp,subs="verbatim,quotes"]
----
// calculate output size
constexpr auto *brain_fuck_output_size*(const char* input) -> size_t {
    struct {
        size_t sz{};
        constexpr void push(...) { ++sz; }
    } dummy;
    return parse(input, dummy).sz + 1; // include '\0'
}

#define BRAIN_FUCK(in) brain_fuck< *brain_fuck_output_size(in)* >(in)
constexpr auto res = BRAIN_FUCK(R"(
    ++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.
    >---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.
)");
----

== constexpr vs æ¨¡æ¿å…ƒç¼–ç¨‹
icon:question[role="orange"]
ç¼–è¯‘æ—¶é—´

image::brain_fuck_perf.png[]

0.13s vs 4.088s ! 30x speed up icon:angle-double-up[role="red"]

=== constexpr vs æ¨¡æ¿å…ƒç¼–ç¨‹
æ¨¡æ¿å…ƒ http://redd.it/jnz5p1[http://redd.it/jnz5p1]

* Looks both *scary* and *exciting* at the same time. :P
* After reading this code I gotta *remove C++* from the programming languages I know list.  Sweet mother of god this is *incredible*! :,)
* Nice, definitely *scary* stuff though.
* Where does one learn to use templates like that? I have no idea what I'm looking at
* From my experience, templates like this are *hard to casually read* even if you are the one who wrote them. It makes perfect sense when you are *creating the monstrosity* though.
* Actually, for what it is, it's incredibly *readable*.
* Awesome, Now make a c++ compiler with brainfuck :p

constexpr http://redd.it/jp7k0u[http://redd.it/jp7k0u]

* Amazing, very neat, show the *power* of constexpr functions, way more *readable* than template.
* Wow. Your constexpr code is vastly more *readable* than the template metaprogramming one.

[.columns]
=== constexpr vs æ¨¡æ¿å…ƒç¼–ç¨‹
[.column]
--
ç®€å•è®¾è®¡ï¼šæ¨¡æ¿å…ƒ

* é€šè¿‡æ‰€æœ‰æµ‹è¯•(static_assert) icon:check-circle[role="green"]
* æ²¡æœ‰é‡å¤ï¼Œæ˜“äºé‡ç”¨ icon:check-circle[role="green"]
* è¡¨è¾¾æ„å›¾ï¼Œæ˜“äºç†è§£ï¼ˆ~200 linesï¼‰ icon:times[role="red"]
* æ²¡æœ‰å†—ä½™ï¼Œé¿å…è¿‡åº¦è®¾è®¡ icon:ellipsis-h[role="orange"]
--

[.column]
--
ç®€å•è®¾è®¡ï¼šconstexpr

* é€šè¿‡æ‰€æœ‰æµ‹è¯•(static_assert) icon:check-circle[role="green"]
* æ²¡æœ‰é‡å¤ï¼Œæ˜“äºé‡ç”¨ icon:check-circle[role="green"]
* è¡¨è¾¾æ„å›¾ï¼Œæ˜“äºç†è§£ï¼ˆ~80 linesï¼‰ icon:check-circle[role="green"]
* æ²¡æœ‰å†—ä½™ï¼Œé¿å…è¿‡åº¦è®¾è®¡ icon:check-circle[role="green"]
--

[.columns]
=== constexpr vs æ¨¡æ¿å…ƒç¼–ç¨‹
[.column]
--
æ¨¡æ¿å…ƒä¼˜ç¼ºç‚¹

* è¿è¡Œæ—¶æ•ˆç‡
* ä½“ç³»æˆç†Ÿï¼Œæ‹¥æœ‰å¤§é‡çš„åº“ +
å‚è€ƒèµ„æ–™å¤š
* å¯å˜å‚æ•°æ¨¡æ¿ç±»å¯ä»¥ä»»æ„æ‰©å®¹
* å¯è¯»æ€§å·®ï¼Œç»´æŠ¤æ€§å·®
* ç¼–è¯‘é”™è¯¯ä¿¡æ¯éš¾æ‡‚ï¼›ç¼–è¯‘é€Ÿåº¦æ…¢ï¼›è·¨å¹³å°ï¼ˆç¼–è¯‘å™¨ï¼‰å¼±
--

[.column]
--
constexprä¼˜ç¼ºç‚¹

* è¿è¡Œæ—¶æ•ˆç‡
* æ–°å…´åŠ¿åŠ›ï¼Œç”Ÿæ€å¾…å®Œå–„ +
å‚è€ƒèµ„æ–™å°‘ï¼ŒæŒ–æ˜ç©ºé—´å¤§
* C++20ä¹‹å‰éœ€è¦æå‰è®¡ç®—å®¹å™¨å¤§å°
* å¯è¯»æ€§å¼ºï¼Œç»´æŠ¤æ€§å¼ºï¼Œæ›´å°‘çš„é­”æ³•
* ç¼–è¯‘é”™è¯¯ä¿¡æ¯æ˜“æ‡‚ï¼›ç¼–è¯‘é€Ÿåº¦å¿«ï¼›è·¨å¹³å°ï¼ˆç¼–è¯‘å™¨ï¼‰å¼º
--

== Constexpr all the things!
image::constexpr-all-the-things.png[80%,80%]

== constexprå†ç¨‹
* C++11 å¼•å…¥constexprç®€å•å‡½æ•°
** åªå…è®¸ä¸€æ¡returnè¯­å¥
** é€’å½’è§£å†³é—®é¢˜ï¼ç®€å•çš„æ•°å­¦å‡½æ•°ã€å­—ç¬¦ä¸²hashå‡½æ•°
* C++14 æ”¾å¼€constexprçº¦æŸ, æ¨¡æ¿å˜é‡
** æ³›åŒ–constexpr
** ä¸€äº›åº“å‡ºç°
* C++17 if constexprã€constexpr lambdaã€æŠ˜å è¡¨è¾¾å¼
** è¡¨è¾¾åŠ›æå‡
* C++20 constexprå®¹å™¨ã€constexpr newã€constexprææ„å‡½æ•°ã€constexprè™šå‡½æ•°ã€consteval/constinitã€lambdaæ¨¡æ¿å‚æ•°
* constexpr STL algorithms

== æ·±å…¥constexpr
* constexprå¸¸é‡
* æŠ˜å è¡¨è¾¾å¼
* constexprå‡½æ•°ã€lambda
* consteval/constinit
* if constexpr
* constexprå®¹å™¨ã€ç®—æ³•
* constexprææ„å‡½æ•°
* æ£€æµ‹Undefined Behaviour

=== constexprå¸¸é‡
[source,cpp]
----
constexpr size_t strLen(const char* str) {
    return (*str == '\0') ? 0 : 1 + strLen(str + 1);
}

#define STR "hello world"
static_assert(strLen(STR) == 11);
----
icon:angle-double-down[role="icon-center"]
[source,cpp,subs="verbatim,quotes"]
----
const char* str = "hello world";
// error: static_assert expression is not an integral *constant expression*
static_assert(strLen(str) == 11);
----
icon:angle-double-down[role="icon-center"]
[source,cpp,subs="verbatim,quotes"]
----
constexpr const char* str = "hello world";
static_assert(strLen(str) == 11);
----

=== constexpræ¨¡æ¿å¸¸é‡
åšå¸¸é‡åˆ«å
[source,cpp]
----
template<class T>
constexpr bool is_class_v = is_class<T>::value;
----

è¡¨è¾¾å¼è®¡ç®—
[source,cpp]
----
template<char c>
constexpr bool is_digit = (c >= '0' && c <= '9');
template<char c>
constexpr bool is_digit_or_dot = (is_digit<c> || c == '.');

static_assert(! is_digit<'x'>);
static_assert(is_digit<'0'>);
----

æ¨¡æ¿ç‰¹åŒ–
[source,cpp]
----
template<size_t N>
constexpr size_t fibonacci = fibonacci<N - 1> + fibonacci<N - 2>;
template<>
constexpr size_t fibonacci<0> = 0;
template<>
constexpr size_t fibonacci<1> = 1;

static_assert(fibonacci<10> == 55);
----

=== æŠ˜å è¡¨è¾¾å¼
[source,cpp,subs="verbatim,quotes"]
----
template<char c, char... cs>
constexpr bool is_sign_valid = ((c == '+' || c == '-') && sizeof...(cs) > 0)
                                || is_digit_or_dot<c>;

template<char... cs>
constexpr size_t number_of_dots = ((cs == '.' ? 1 : 0) + *...* + 0);

template<char c, char... cs>
constexpr bool is_integer = is_sign_valid<c, cs...> &&
                            (is_digit<cs> && *...*);

template<char... cs>
constexpr bool is_double = is_sign_valid<cs...> &&
                           ( (is_digit_or_dot<cs>) && *...*) &&
                           number_of_dots<cs...> == 1;

template<char... cs>
constexpr bool is_number_valid = (is_integer<cs...> || is_double<cs...>);

static_assert(is_number_valid<'1', '2', '3', '.', '4'>);
static_assert(! is_number_valid<'a', 'b', 'c', 'd'>);
----

=== constexpr å‡½æ•° & lambda
C++17èµ·ï¼Œlambdaé»˜è®¤ä¸ºconstexpr
[source,cpp]
----
// constexpr int fibonacci(int n);
auto fibonacci = [](int n) {
    int a = 0, b = 1;
    for (int c = 0; c < n; ++ c) {
        int t = a + b;
        a = b;
        b = t;
    }
    return a;
};

constexpr auto v = fibonacci(10);
static_assert(v == 55);
----

=== consteval/constinit
consteval::
specifies that a function is an immediate function, that is, every call to the function must produce a *compile-time* constant.
constinit::
asserts that a variable has *static initialization*, i.e. zero initialization and constant initialization, otherwise the program is ill-formed.

=== if constexpr
icon:question[role="orange"]
å¦‚ä½•æ±‚ç»“æ„ä½“å­—æ®µä¸ªæ•°

[source,cpp]
----
struct AnyType {
    template <typename T>
    operator T();
};

template <typename T>
consteval size_t CountMember(auto&&... Args) {
    if constexpr (requires { T{ Args... }; }) {    // <1>
        return CountMember<T>(Args..., AnyType{}); // <2>
    } else {
        return sizeof...(Args) - 1;                // <3>
    }
}

struct Test { int a; int b; int c; int d; };
static_assert(CountMember<Test>() == 4);
----

<1> åˆ¤æ–­å½“å‰å‚æ•°åŒ…æ˜¯å¦èƒ½å¤ŸæˆåŠŸ *èšåˆåˆå§‹åŒ–* å¯¹è±¡Tï¼ŒC++20 conceptç‰¹æ€§
<2> è‹¥ *èšåˆåˆå§‹åŒ–* æˆåŠŸï¼Œä¸æ–­æ·»åŠ å‚æ•°å¯¹Tè¿›è¡Œè¿›ä¸€æ­¥ *èšåˆåˆå§‹åŒ–*
<3> è‹¥ *èšåˆåˆå§‹åŒ–* å¤±è´¥ï¼Œå­—æ®µä¸ªæ•°ä¸ºå‚æ•°ä¸ªæ•°-1

=== constexprå®¹å™¨ã€ç®—æ³•
image::constexpr_vector_construct.png[]

image::constexpr_vector_destructor.png[80%, 50%]

image::constexpr_sort.png[]

=== constexprææ„å‡½æ•° - ææ„ä¼˜åŒ–
icon:question[role="orange"]
å¦‚ä½•ä¼˜åŒ–
[source,cpp]
----
struct OptionalTrivially {};

template <typename T, typename Contained>
struct OptionalNonTrivially {
    ~OptionalNonTrivially() {
        if (static_cast<T*>(this)->initialized_) {
            static_cast<T*>(this)->storage_.data.~Contained();
        }
    }
};

template <typename Contained>
struct Optional: conditional_t<is_trivially_destructible_v<Contained>,
                               OptionalTrivially,
                               OptionalNonTrivially<Optional<Contained>, Contained>> {
    constexpr Optional& operator=(Contained&& data) {
        storage_.data = std::move(data);
        initialized_ = true;
        return *this;
    }

    Storage<Contained> storage_;
    bool initialized_{};
};
----

=== constexprææ„å‡½æ•° - ä½¿ç”¨if constexpr
[source,cpp]
----
template <typename Contained>
struct Optional {
    constexpr Optional& operator=(Contained&& data) {
        storage_.data = std::move(data);
        initialized_ = true;
        return *this;
    }

    constexpr ~Optional() {
        if constexpr(! is_trivially_destructible_v<Contained>) {
            if (initialized_) {
                this->storage_.data.~Contained();
                initialized_ = false;
            }
        }
    }

    Storage<Contained> storage_;
    bool initialized_{};
};
----

=== constexprææ„å‡½æ•° - ä½¿ç”¨æ¦‚å¿µçº¦æŸ
[source,cpp]
----
template <typename Contained>
struct Optional {
    constexpr Optional& operator=(Contained&& data) {
        storage_.data = std::move(data);
        initialized_ = true;
        return *this;
    }

    constexpr ~Optional() requires (! is_trivially_destructible_v<Contained>) {
        if (initialized_) {
            this->storage_.data.~Contained();
        }
    }
    constexpr ~Optional() = default;

    Storage<Contained> storage_;
    bool initialized_{};
};
----

=== æ£€æµ‹Undefined Behaviour
[source,cpp]
----
const double x1=100/0;                               // <1>
const int x2 = std::numeric_limits<int>::min() / -1; // <2>

constexpr double y1=100/0;                               // <3>
constexpr int y2 = std::numeric_limits<int>::min() / -1; // <4>
----

<1> warning: division by zero
<2> no warning in clang
<3> error: division by zero is not a constant expression
<4> error: overflow in constant expression

[source,cpp]
----
constexpr int bar() {
    int* p = nullptr;
    return *p;
}

constexpr auto foo = bar(); // <1>
----
<1> error: dereferencing a null pointer

=== æ£€æµ‹Undefined Behaviour
[source,cpp]
----
constexpr int foo(const int *p) {
    return *(p + 12); <1>
}

constexpr void bar() {
    constexpr int arr[10]{};
    constexpr int x = foo(arr);
}
----
<1> error: array subscript value '12' is outside the bounds of array 'arr' of type 'const int [10]'

[source,cpp]
----
constexpr int& foo(){
    int x = 23;
    return x;
}

constexpr int bar() {
    constexpr int x = foo(); <1>
    return x;
}
----
<1> error: constexpr variable 'x' must be initialized by a constant expression. note: read of variable whose lifetime has ended

=== æ£€æµ‹Undefined Behaviour
[source,cpp]
----
constexpr int foo(int x) {
   if(x) return 1;
}

void bar(){
    constexpr int x = foo(0); <1>
}
----
<1> error: 'constexpr' call flows off the end of the function

icon:question[role="orange"]
å¦‚ä¸‹ä»£ç çš„æ„å›¾

[source,cpp]
----
constexpr void push_back(Value t_v) {
    if (m_size >= Size) {
        throw std::range_error("Index past end of vector");
    } else {
        m_data[m_size++] = std::move(t_v);
    }
}
----

è¾…åŠ©å·¥å…·ï¼š https://github.com/trailofbits/constexpr-everything[https://github.com/trailofbits/constexpr-everything]

== constexpråº”ç”¨
* é¢†åŸŸç‰¹å®šè¯­è¨€(EDSL)
** ç¼–è¯‘æœŸè§£æJson (Parser Combinator)
** ç¼–è¯‘æœŸæ„å»ºæ­£åˆ™è¡¨è¾¾å¼FSM (LL1åˆ†æå™¨)
** constexpr-sql (é€’å½’ä¸‹é™åˆ†æå™¨)
** graph-dsl (è¯­æ³•æ ‘æ–‡æ³•ï¼Œlispé£æ ¼)
* constexprå…ƒç¼–ç¨‹åº“
** boost::hana
** holo

== é¢†åŸŸç‰¹å®šè¯­è¨€(EDSL)
=== ç¼–è¯‘æœŸè§£æJson (Parser Combinator)
å®Œæ•´Talkï¼š https://www.youtube.com/watch?v=PJwd4JLYJJY[CppCon 2017: Ben Deane & Jason Turner â€œconstexpr ALL the Things!â€]
[source,cpp]
----
constexpr auto jsv
  = R"({
        "feature-x-enabled": true,
        "value-of-y": 1729,
        "z-options": {"a": null,
                      "b": "220 and 284",
                      "c": [6, 28, 496]}
       })"_json;
if constexpr (jsv["feature-x-enabled"]) {
  // code for feature x
} else {
  // code when feature x turned off
}
----

=== ç¼–è¯‘æœŸè§£æJson (Parser Combinator)
Parser Combinator:
[source,cpp]
----
template <typename T>
using Parser = auto(*)(string_view) -> optional<pair<T, ParserInput>>;
----
[source,cpp]
----
// a parser for skipping whitespace
constexpr auto skip_whitespace() {
    constexpr auto ws_parser = make_char_parser(' ')
                             | make_char_parser('\t')
                             | make_char_parser('\n')
                             | make_char_parser('\r');
    return many(ws_parser, std::monostate{}, [] (auto m, auto) { return m; });
}

// parse a JSON array
static constexpr auto array_parser() {
    return make_char_parser('[') <
            separated_by_val(value_parser(),
                            skip_whitespace() < make_char_parser(','),
                            Sizes{1, 0}, std::plus<>{})
            > skip_whitespace()
        > (make_char_parser(']') | fail(']', [] { throw "expected ]"; }));
}
----

=== ç¼–è¯‘æœŸæ­£åˆ™è¡¨è¾¾å¼(LL1åˆ†æå™¨)
https://github.com/hanickadot/compile-time-regular-expressions[https://github.com/hanickadot/compile-time-regular-expressions]

[source,cpp]
----
struct date {
    std::string_view year;
    std::string_view month;
    std::string_view day;
};

std::optional<date> extract_date(std::string_view s) {
    if (auto [whole, year, month, day] =
            ctre::match<"(\\d{4})/(\\d{1,2})/(\\d{1,2})">(s); whole) {
        return date{year, month, day};
    } else {
        return std::nullopt;
    }
}

static_assert(extract_date("2018/08/27"sv).has_value());
static_assert((*extract_date("2018/08/27"sv)).year == "2018"sv);
static_assert((*extract_date("2018/08/27"sv)).month == "08"sv);
static_assert((*extract_date("2018/08/27"sv)).day == "27"sv);
----

=== constexpr-sql (é€’å½’ä¸‹é™åˆ†æå™¨)
https://github.com/mkitzan/constexpr-sql[https://github.com/mkitzan/constexpr-sql]
[source,cpp]
----
using books = sql::schema<"books",
        sql::index<"title">,
		sql::column<"title", std::string>,
		sql::column<"genre", std::string>,
		sql::column<"year",  unsigned>,
		sql::column<"pages", unsigned>>;

using authored = sql::schema<"authored",
        sql::index<>,
		sql::column<"title", std::string>,
		sql::column<"name",  std::string>>;

using query = sql::query<R"(
    SELECT title AS book, name AS author, year, pages
    FROM books NATURAL JOIN (SELECT * FROM authored WHERE name = "Harlan Ellison")
    WHERE year = 1967 OR year >= 1972 AND genre = "science fiction"
    )", books, authored>;

authored a { sql::load<authored>("tests/data/authored.tsv", '\t') };
books    b { sql::load<books>("tests/data/books.tsv",       '\t') };

for (query q { b, a }; auto const& [book, author, year, pages]: q)
    std::cout << book << '\t' << author << '\t' << year << '\t' << pages << '\n';
----

=== graph-dsl (è¯­æ³•æ ‘æ–‡æ³•ï¼Œlispé£æ ¼)
https://github.com/godsme/graph-dsl[https://github.com/godsme/graph-dsl]
[source,cpp]
----
using sub_graph_1 = SUBGRAPH(
    (root_0 , (port_1) -> node_8
            , (port_2) -> MAYBE(cond_2, node_3)
            , (port_3) -> EITHER(cond_1, node_8, node_4)
            , (port_4) -> FORK(node_5, node_4, MAYBE(cond_2, node_8))),
    (node_5 , (port_5) -> node_8
            , (port_6) -> FORK(node_4, MAYBE(cond_2, node_3))),
    (node_3 , (port_7) -> node_4
            , (port_8) -> FORK(node_8, node_6)
            , (port_9) -> node_7));

using sub_graph_2 = SUBGRAPH(
    (root_0  , (port_1) -> node_9),
    (root_1  , (port_1) -> node_10
             , (port_2) -> MAYBE(cond_2, node_11)
             , (port_3) -> EITHER(cond_1, node_12, node_13)),
    (node_11 , (port_10) -> node_12
             , (port_11) -> FORK(node_13, node_14)
             , (port_12) -> node_15));

using graph = GRAPH(
    (root_0, root_1),
    (cond_3) -> sub_graph_1,
    (cond_4) -> sub_graph_2);

graph g;
while (g.refresh(context) == OK) { };
----

== constexprå…ƒç¼–ç¨‹åº“
=== boost::hana
https://www.boost.org/doc/libs/1_61_0/libs/hana/doc/html/index.html[https://www.boost.org/doc/libs/1_61_0/libs/hana/doc/html/index.html]
[source,cpp]
----
constexpr auto result = append(make_tuple(type_c<int>, type_c<double>), type_c<long>);
static_assert(make_basic_tuple(type_c<int>, type_c<double>, type_c<long>) == result);

constexpr auto result = concat(make_tuple(type_c<int>, type_c<double>),
                               make_tuple(type_c<long>, type_c<float>));
static_assert(make_basic_tuple(
        type_c<int>, type_c<double>, type_c<long>, type_c<float>
    ) == result);

auto result = partition(tuple_t<int, double, double, int>,
                        [](auto x) { return x == type_c<int>; });
static_assert(make_pair(tuple_t<int, int>, tuple_t<double, double>) == result);
----

=== holo
ç¼–è¯‘æœŸRanges: https://github.com/godsme/holo[https://github.com/godsme/holo]
[source,cpp]
----
constexpr static auto sorted_non_leaf_nodes =
    all_decedents_map
    | holo::sort([](auto l, auto r) {
        return holo::contains(holo::first(l), holo::second(r)); })
    | holo::transform([](auto elem) {
        return holo::first(elem); })
    | holo::reverse();


constexpr static auto root_nodes =
    holo::list_t<NODES...>
    | holo::filter([](auto elem){
        return decltype(elem)::type::is_root == holo::true_c; })
    | holo::transform([](auto elem){
        return holo::type_c<typename decltype(elem)::type::node_type>;
    });
----

== Reference
* http://odinthenerd.blogspot.com/2014/07/introduction-to-c-metaprogramming-part-1.html[Introduction to C++ Metaprogramming]
* https://www.youtube.com/watch?v=A3_xrqr5Kdw[C++ Weekly - Ep 231 - Multiple Destructors in C++20?! How and Why]
* https://github.com/trailofbits/constexpr-everything[https://github.com/trailofbits/constexpr-everything]
* https://shafik.github.io/c++/undefined%20behavior/2019/05/11/explporing_undefined_behavior_using_constexpr.html[Exploring Undefined Behavior Using Constexpr]
* https://www.youtube.com/watch?v=PJwd4JLYJJY[CppCon 2017: Ben Deane & Jason Turner â€œconstexpr ALL the Things!â€]

